// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: v1alpha1/proto/grafeas.proto

/*
	Package grafeas is a generated protocol buffer package.

	It is generated from these files:
		v1alpha1/proto/grafeas.proto

	It has these top-level messages:
		GetOccurrenceRequest
		ListOccurrencesRequest
		DeleteOccurrenceRequest
		CreateOccurrenceRequest
		UpdateOccurrenceRequest
		GetNoteRequest
		GetOccurrenceNoteRequest
		ListNotesRequest
		DeleteNoteRequest
		CreateNoteRequest
		UpdateNoteRequest
		ListNoteOccurrencesRequest
		ListNoteOccurrencesResponse
		ListNotesResponse
		ListOccurrencesResponse
		ListOperationsResponse
		UpdateOperationRequest
		CreateOperationRequest
		OperationMetadata
		Artifact
		AttestationAuthority
		BuildDetails
		BuildProvenance
		BuildSignature
		BuildType
		Command
		Deployable
		DockerImage
		Discovery
		FileHashes
		Hash
		Note
		Occurrence
		PackageManager
		PgpSignedAttestation
		Source
		RepoSource
		StorageSource
		VulnerabilityType
*/
package grafeas

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"
import _ "github.com/golang/protobuf/ptypes/empty"
import _ "google.golang.org/genproto/googleapis/api/annotations"
import google_protobuf2 "github.com/golang/protobuf/ptypes/timestamp"
import google_longrunning "google.golang.org/genproto/googleapis/longrunning"
import google_devtools_source_v1 "google.golang.org/genproto/googleapis/devtools/source/v1"

import encoding_binary "encoding/binary"

import io "io"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion2 // please upgrade the proto package

// The type of the key, either stored in `public_key` or referenced in
// `key_id`
type BuildSignature_KeyType int32

const (
	BuildSignature_UNSET             BuildSignature_KeyType = 0
	BuildSignature_PGP_ASCII_ARMORED BuildSignature_KeyType = 1
	BuildSignature_PKIX_PEM          BuildSignature_KeyType = 2
)

var BuildSignature_KeyType_name = map[int32]string{
	0: "UNSET",
	1: "PGP_ASCII_ARMORED",
	2: "PKIX_PEM",
}
var BuildSignature_KeyType_value = map[string]int32{
	"UNSET":             0,
	"PGP_ASCII_ARMORED": 1,
	"PKIX_PEM":          2,
}

func (x BuildSignature_KeyType) String() string {
	return proto.EnumName(BuildSignature_KeyType_name, int32(x))
}
func (BuildSignature_KeyType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptorGrafeas, []int{23, 0}
}

// The recovered Dockerfile directive used to construct this layer.
type DockerImage_Layer_Directive int32

const (
	DockerImage_Layer_UNKNOWN_DIRECTIVE DockerImage_Layer_Directive = 0
	DockerImage_Layer_MAINTAINER        DockerImage_Layer_Directive = 1
	DockerImage_Layer_RUN               DockerImage_Layer_Directive = 2
	DockerImage_Layer_CMD               DockerImage_Layer_Directive = 3
	DockerImage_Layer_LABEL             DockerImage_Layer_Directive = 4
	DockerImage_Layer_EXPOSE            DockerImage_Layer_Directive = 5
	DockerImage_Layer_ENV               DockerImage_Layer_Directive = 6
	DockerImage_Layer_ADD               DockerImage_Layer_Directive = 7
	DockerImage_Layer_COPY              DockerImage_Layer_Directive = 8
	DockerImage_Layer_ENTRYPOINT        DockerImage_Layer_Directive = 9
	DockerImage_Layer_VOLUME            DockerImage_Layer_Directive = 10
	DockerImage_Layer_USER              DockerImage_Layer_Directive = 11
	DockerImage_Layer_WORKDIR           DockerImage_Layer_Directive = 12
	DockerImage_Layer_ARG               DockerImage_Layer_Directive = 13
	DockerImage_Layer_ONBUILD           DockerImage_Layer_Directive = 14
	DockerImage_Layer_STOPSIGNAL        DockerImage_Layer_Directive = 15
	DockerImage_Layer_HEALTHCHECK       DockerImage_Layer_Directive = 16
	DockerImage_Layer_SHELL             DockerImage_Layer_Directive = 17
)

var DockerImage_Layer_Directive_name = map[int32]string{
	0:  "UNKNOWN_DIRECTIVE",
	1:  "MAINTAINER",
	2:  "RUN",
	3:  "CMD",
	4:  "LABEL",
	5:  "EXPOSE",
	6:  "ENV",
	7:  "ADD",
	8:  "COPY",
	9:  "ENTRYPOINT",
	10: "VOLUME",
	11: "USER",
	12: "WORKDIR",
	13: "ARG",
	14: "ONBUILD",
	15: "STOPSIGNAL",
	16: "HEALTHCHECK",
	17: "SHELL",
}
var DockerImage_Layer_Directive_value = map[string]int32{
	"UNKNOWN_DIRECTIVE": 0,
	"MAINTAINER":        1,
	"RUN":               2,
	"CMD":               3,
	"LABEL":             4,
	"EXPOSE":            5,
	"ENV":               6,
	"ADD":               7,
	"COPY":              8,
	"ENTRYPOINT":        9,
	"VOLUME":            10,
	"USER":              11,
	"WORKDIR":           12,
	"ARG":               13,
	"ONBUILD":           14,
	"STOPSIGNAL":        15,
	"HEALTHCHECK":       16,
	"SHELL":             17,
}

func (x DockerImage_Layer_Directive) String() string {
	return proto.EnumName(DockerImage_Layer_Directive_name, int32(x))
}
func (DockerImage_Layer_Directive) EnumDescriptor() ([]byte, []int) {
	return fileDescriptorGrafeas, []int{27, 0, 0}
}

// The type of hash that was performed.
type Hash_Type int32

const (
	Hash_NONE   Hash_Type = 0
	Hash_SHA256 Hash_Type = 1
	Hash_MD5    Hash_Type = 2
)

var Hash_Type_name = map[int32]string{
	0: "NONE",
	1: "SHA256",
	2: "MD5",
}
var Hash_Type_value = map[string]int32{
	"NONE":   0,
	"SHA256": 1,
	"MD5":    2,
}

func (x Hash_Type) String() string {
	return proto.EnumName(Hash_Type_name, int32(x))
}
func (Hash_Type) EnumDescriptor() ([]byte, []int) { return fileDescriptorGrafeas, []int{30, 0} }

// This must be 1:1 with members of our oneofs, it can be used for filtering
// Note and Occurrence on their kind.
type Note_Kind int32

const (
	// Unknown
	Note_KIND_UNSPECIFIED Note_Kind = 0
	// The note and occurrence represent a package vulnerability.
	Note_PACKAGE_VULNERABILITY Note_Kind = 1
	// The note and occurrence assert build provenance.
	Note_BUILD_DETAILS Note_Kind = 2
	// This represents an image basis relationship.
	Note_IMAGE_BASIS Note_Kind = 3
	// This represents a package installed via a package manager.
	Note_PACKAGE_MANAGER Note_Kind = 4
	// The note and occurrence track deployment events.
	Note_DEPLOYABLE Note_Kind = 5
	// The note and occurrence track the initial discovery status of a resource.
	Note_DISCOVERY Note_Kind = 6
	// This represents a logical "role" that can attest to artifacts.
	Note_ATTESTATION_AUTHORITY Note_Kind = 7
)

var Note_Kind_name = map[int32]string{
	0: "KIND_UNSPECIFIED",
	1: "PACKAGE_VULNERABILITY",
	2: "BUILD_DETAILS",
	3: "IMAGE_BASIS",
	4: "PACKAGE_MANAGER",
	5: "DEPLOYABLE",
	6: "DISCOVERY",
	7: "ATTESTATION_AUTHORITY",
}
var Note_Kind_value = map[string]int32{
	"KIND_UNSPECIFIED":      0,
	"PACKAGE_VULNERABILITY": 1,
	"BUILD_DETAILS":         2,
	"IMAGE_BASIS":           3,
	"PACKAGE_MANAGER":       4,
	"DEPLOYABLE":            5,
	"DISCOVERY":             6,
	"ATTESTATION_AUTHORITY": 7,
}

func (x Note_Kind) String() string {
	return proto.EnumName(Note_Kind_name, int32(x))
}
func (Note_Kind) EnumDescriptor() ([]byte, []int) { return fileDescriptorGrafeas, []int{31, 0} }

// The CPU architecture for which packages in this distribution
// channel were built
type PackageManager_Distribution_Architecture int32

const (
	PackageManager_Distribution_UNKNOWN PackageManager_Distribution_Architecture = 0
	PackageManager_Distribution_X86     PackageManager_Distribution_Architecture = 1
	PackageManager_Distribution_X64     PackageManager_Distribution_Architecture = 2
)

var PackageManager_Distribution_Architecture_name = map[int32]string{
	0: "UNKNOWN",
	1: "X86",
	2: "X64",
}
var PackageManager_Distribution_Architecture_value = map[string]int32{
	"UNKNOWN": 0,
	"X86":     1,
	"X64":     2,
}

func (x PackageManager_Distribution_Architecture) String() string {
	return proto.EnumName(PackageManager_Distribution_Architecture_name, int32(x))
}
func (PackageManager_Distribution_Architecture) EnumDescriptor() ([]byte, []int) {
	return fileDescriptorGrafeas, []int{33, 1, 0}
}

// Whether this is an ordinary package version or a
// sentinel MIN/MAX version.
type PackageManager_Version_VersionKind int32

const (
	// A standard package version, defined by the other fields.
	PackageManager_Version_NORMAL PackageManager_Version_VersionKind = 0
	// A special version representing negative infinity,
	// other fields are ignored.
	PackageManager_Version_MINIMUM PackageManager_Version_VersionKind = 1
	// A special version representing positive infinity,
	// other fields are ignored.
	PackageManager_Version_MAXIMUM PackageManager_Version_VersionKind = 2
)

var PackageManager_Version_VersionKind_name = map[int32]string{
	0: "NORMAL",
	1: "MINIMUM",
	2: "MAXIMUM",
}
var PackageManager_Version_VersionKind_value = map[string]int32{
	"NORMAL":  0,
	"MINIMUM": 1,
	"MAXIMUM": 2,
}

func (x PackageManager_Version_VersionKind) String() string {
	return proto.EnumName(PackageManager_Version_VersionKind_name, int32(x))
}
func (PackageManager_Version_VersionKind) EnumDescriptor() ([]byte, []int) {
	return fileDescriptorGrafeas, []int{33, 2, 0}
}

// Type (e.g. schema) of the attestation payload that was signed.
type PgpSignedAttestation_ContentType int32

const (
	// ContentType is not set.
	PgpSignedAttestation_CONTENT_TYPE_UNSPECIFIED PgpSignedAttestation_ContentType = 0
	// Atomic format attestation signature. See
	// https://github.com/containers/image/blob/8a5d2f82a6e3263290c8e0276c3e0f64e77723e7/docs/atomic-signature.md
	// The payload extracted from `signature` is a JSON blob conforming to the
	// linked schema.
	PgpSignedAttestation_SIMPLE_SIGNING_JSON PgpSignedAttestation_ContentType = 1
)

var PgpSignedAttestation_ContentType_name = map[int32]string{
	0: "CONTENT_TYPE_UNSPECIFIED",
	1: "SIMPLE_SIGNING_JSON",
}
var PgpSignedAttestation_ContentType_value = map[string]int32{
	"CONTENT_TYPE_UNSPECIFIED": 0,
	"SIMPLE_SIGNING_JSON":      1,
}

func (x PgpSignedAttestation_ContentType) String() string {
	return proto.EnumName(PgpSignedAttestation_ContentType_name, int32(x))
}
func (PgpSignedAttestation_ContentType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptorGrafeas, []int{34, 0}
}

// Note provider-assigned severity/impact ranking
type VulnerabilityType_Severity int32

const (
	VulnerabilityType_SEVERITY_UNSPECIFIED VulnerabilityType_Severity = 0
	VulnerabilityType_MINIMAL              VulnerabilityType_Severity = 1
	VulnerabilityType_LOW                  VulnerabilityType_Severity = 2
	VulnerabilityType_MEDIUM               VulnerabilityType_Severity = 3
	VulnerabilityType_HIGH                 VulnerabilityType_Severity = 4
	VulnerabilityType_CRITICAL             VulnerabilityType_Severity = 5
)

var VulnerabilityType_Severity_name = map[int32]string{
	0: "SEVERITY_UNSPECIFIED",
	1: "MINIMAL",
	2: "LOW",
	3: "MEDIUM",
	4: "HIGH",
	5: "CRITICAL",
}
var VulnerabilityType_Severity_value = map[string]int32{
	"SEVERITY_UNSPECIFIED": 0,
	"MINIMAL":              1,
	"LOW":                  2,
	"MEDIUM":               3,
	"HIGH":                 4,
	"CRITICAL":             5,
}

func (x VulnerabilityType_Severity) String() string {
	return proto.EnumName(VulnerabilityType_Severity_name, int32(x))
}
func (VulnerabilityType_Severity) EnumDescriptor() ([]byte, []int) {
	return fileDescriptorGrafeas, []int{38, 0}
}

// Whether this is an ordinary package version or a
// sentinel MIN/MAX version.
type VulnerabilityType_Version_VersionKind int32

const (
	// A standard package version, defined by the other fields.
	VulnerabilityType_Version_NORMAL VulnerabilityType_Version_VersionKind = 0
	// A special version representing negative infinity,
	// other fields are ignored.
	VulnerabilityType_Version_MINIMUM VulnerabilityType_Version_VersionKind = 1
	// A special version representing positive infinity,
	// other fields are ignored.
	VulnerabilityType_Version_MAXIMUM VulnerabilityType_Version_VersionKind = 2
)

var VulnerabilityType_Version_VersionKind_name = map[int32]string{
	0: "NORMAL",
	1: "MINIMUM",
	2: "MAXIMUM",
}
var VulnerabilityType_Version_VersionKind_value = map[string]int32{
	"NORMAL":  0,
	"MINIMUM": 1,
	"MAXIMUM": 2,
}

func (x VulnerabilityType_Version_VersionKind) String() string {
	return proto.EnumName(VulnerabilityType_Version_VersionKind_name, int32(x))
}
func (VulnerabilityType_Version_VersionKind) EnumDescriptor() ([]byte, []int) {
	return fileDescriptorGrafeas, []int{38, 0, 0}
}

// Request to get a Occurrence.
type GetOccurrenceRequest struct {
	// The name of the occurrence in the form
	// "projects/{project_id}/occurrences/{occurrence_id}"
	Name string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
}

func (m *GetOccurrenceRequest) Reset()                    { *m = GetOccurrenceRequest{} }
func (m *GetOccurrenceRequest) String() string            { return proto.CompactTextString(m) }
func (*GetOccurrenceRequest) ProtoMessage()               {}
func (*GetOccurrenceRequest) Descriptor() ([]byte, []int) { return fileDescriptorGrafeas, []int{0} }

func (m *GetOccurrenceRequest) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

// Request to list occurrences.
type ListOccurrencesRequest struct {
	// This contains the projectId for example: projects/{project_id}
	Parent string `protobuf:"bytes,5,opt,name=parent,proto3" json:"parent,omitempty"`
	// The filter expression.
	Filter string `protobuf:"bytes,2,opt,name=filter,proto3" json:"filter,omitempty"`
	// Number of occurrences to return in the list.
	PageSize int32 `protobuf:"varint,3,opt,name=page_size,json=pageSize,proto3" json:"page_size,omitempty"`
	// Token to provide to skip to a particular spot in the list.
	PageToken string `protobuf:"bytes,4,opt,name=page_token,json=pageToken,proto3" json:"page_token,omitempty"`
}

func (m *ListOccurrencesRequest) Reset()                    { *m = ListOccurrencesRequest{} }
func (m *ListOccurrencesRequest) String() string            { return proto.CompactTextString(m) }
func (*ListOccurrencesRequest) ProtoMessage()               {}
func (*ListOccurrencesRequest) Descriptor() ([]byte, []int) { return fileDescriptorGrafeas, []int{1} }

func (m *ListOccurrencesRequest) GetParent() string {
	if m != nil {
		return m.Parent
	}
	return ""
}

func (m *ListOccurrencesRequest) GetFilter() string {
	if m != nil {
		return m.Filter
	}
	return ""
}

func (m *ListOccurrencesRequest) GetPageSize() int32 {
	if m != nil {
		return m.PageSize
	}
	return 0
}

func (m *ListOccurrencesRequest) GetPageToken() string {
	if m != nil {
		return m.PageToken
	}
	return ""
}

// Request to delete a occurrence
type DeleteOccurrenceRequest struct {
	// The name of the occurrence in the form
	// "projects/{project_id}/occurrences/{occurrence_id}"
	Name string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
}

func (m *DeleteOccurrenceRequest) Reset()                    { *m = DeleteOccurrenceRequest{} }
func (m *DeleteOccurrenceRequest) String() string            { return proto.CompactTextString(m) }
func (*DeleteOccurrenceRequest) ProtoMessage()               {}
func (*DeleteOccurrenceRequest) Descriptor() ([]byte, []int) { return fileDescriptorGrafeas, []int{2} }

func (m *DeleteOccurrenceRequest) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

// Request to insert a new occurrence
type CreateOccurrenceRequest struct {
	// This field contains the projectId for example: "projects/{project_id}"
	Parent string `protobuf:"bytes,3,opt,name=parent,proto3" json:"parent,omitempty"`
	// The occurrence to be inserted
	Occurrence *Occurrence `protobuf:"bytes,2,opt,name=occurrence" json:"occurrence,omitempty"`
}

func (m *CreateOccurrenceRequest) Reset()                    { *m = CreateOccurrenceRequest{} }
func (m *CreateOccurrenceRequest) String() string            { return proto.CompactTextString(m) }
func (*CreateOccurrenceRequest) ProtoMessage()               {}
func (*CreateOccurrenceRequest) Descriptor() ([]byte, []int) { return fileDescriptorGrafeas, []int{3} }

func (m *CreateOccurrenceRequest) GetParent() string {
	if m != nil {
		return m.Parent
	}
	return ""
}

func (m *CreateOccurrenceRequest) GetOccurrence() *Occurrence {
	if m != nil {
		return m.Occurrence
	}
	return nil
}

// Request to update an existing occurrence
type UpdateOccurrenceRequest struct {
	// The name of the occurrence.
	// Should be of the form "projects/{project_id}/occurrences/{occurrence_id}".
	Name string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	// The updated occurrence.
	Occurrence *Occurrence `protobuf:"bytes,2,opt,name=occurrence" json:"occurrence,omitempty"`
}

func (m *UpdateOccurrenceRequest) Reset()                    { *m = UpdateOccurrenceRequest{} }
func (m *UpdateOccurrenceRequest) String() string            { return proto.CompactTextString(m) }
func (*UpdateOccurrenceRequest) ProtoMessage()               {}
func (*UpdateOccurrenceRequest) Descriptor() ([]byte, []int) { return fileDescriptorGrafeas, []int{4} }

func (m *UpdateOccurrenceRequest) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *UpdateOccurrenceRequest) GetOccurrence() *Occurrence {
	if m != nil {
		return m.Occurrence
	}
	return nil
}

// Request to get a Note.
type GetNoteRequest struct {
	// The name of the note in the form
	// "providers/{provider_id}/notes/{note_id}"
	Name string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
}

func (m *GetNoteRequest) Reset()                    { *m = GetNoteRequest{} }
func (m *GetNoteRequest) String() string            { return proto.CompactTextString(m) }
func (*GetNoteRequest) ProtoMessage()               {}
func (*GetNoteRequest) Descriptor() ([]byte, []int) { return fileDescriptorGrafeas, []int{5} }

func (m *GetNoteRequest) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

// Request to get the note to which this occurrence is attached.
type GetOccurrenceNoteRequest struct {
	// The name of the occurrence in the form
	// "projects/{project_id}/occurrences/{occurrence_id}"
	Name string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
}

func (m *GetOccurrenceNoteRequest) Reset()                    { *m = GetOccurrenceNoteRequest{} }
func (m *GetOccurrenceNoteRequest) String() string            { return proto.CompactTextString(m) }
func (*GetOccurrenceNoteRequest) ProtoMessage()               {}
func (*GetOccurrenceNoteRequest) Descriptor() ([]byte, []int) { return fileDescriptorGrafeas, []int{6} }

func (m *GetOccurrenceNoteRequest) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

// Request to list notes.
type ListNotesRequest struct {
	// The name field will contain the projectId for example:
	// "providers/{provider_id}
	// @Deprecated
	Name string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	// This field contains the projectId for example:
	// "project/{project_id}
	Parent string `protobuf:"bytes,5,opt,name=parent,proto3" json:"parent,omitempty"`
	// The filter expression.
	Filter string `protobuf:"bytes,2,opt,name=filter,proto3" json:"filter,omitempty"`
	// Number of notes to return in the list.
	PageSize int32 `protobuf:"varint,3,opt,name=page_size,json=pageSize,proto3" json:"page_size,omitempty"`
	// Token to provide to skip to a particular spot in the list.
	PageToken string `protobuf:"bytes,4,opt,name=page_token,json=pageToken,proto3" json:"page_token,omitempty"`
}

func (m *ListNotesRequest) Reset()                    { *m = ListNotesRequest{} }
func (m *ListNotesRequest) String() string            { return proto.CompactTextString(m) }
func (*ListNotesRequest) ProtoMessage()               {}
func (*ListNotesRequest) Descriptor() ([]byte, []int) { return fileDescriptorGrafeas, []int{7} }

func (m *ListNotesRequest) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *ListNotesRequest) GetParent() string {
	if m != nil {
		return m.Parent
	}
	return ""
}

func (m *ListNotesRequest) GetFilter() string {
	if m != nil {
		return m.Filter
	}
	return ""
}

func (m *ListNotesRequest) GetPageSize() int32 {
	if m != nil {
		return m.PageSize
	}
	return 0
}

func (m *ListNotesRequest) GetPageToken() string {
	if m != nil {
		return m.PageToken
	}
	return ""
}

// Request to delete a note
type DeleteNoteRequest struct {
	// The name of the note in the form
	// "providers/{provider_id}/notes/{note_id}"
	Name string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
}

func (m *DeleteNoteRequest) Reset()                    { *m = DeleteNoteRequest{} }
func (m *DeleteNoteRequest) String() string            { return proto.CompactTextString(m) }
func (*DeleteNoteRequest) ProtoMessage()               {}
func (*DeleteNoteRequest) Descriptor() ([]byte, []int) { return fileDescriptorGrafeas, []int{8} }

func (m *DeleteNoteRequest) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

// Request to insert a new note
type CreateNoteRequest struct {
	// The name of the project.
	// Should be of the form "providers/{provider_id}".
	// @Deprecated
	Name string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	// This field contains the projectId for example:
	// "project/{project_id}
	Parent string `protobuf:"bytes,4,opt,name=parent,proto3" json:"parent,omitempty"`
	// The ID to use for this note.
	NoteId string `protobuf:"bytes,2,opt,name=note_id,json=noteId,proto3" json:"note_id,omitempty"`
	// The Note to be inserted
	Note *Note `protobuf:"bytes,3,opt,name=note" json:"note,omitempty"`
}

func (m *CreateNoteRequest) Reset()                    { *m = CreateNoteRequest{} }
func (m *CreateNoteRequest) String() string            { return proto.CompactTextString(m) }
func (*CreateNoteRequest) ProtoMessage()               {}
func (*CreateNoteRequest) Descriptor() ([]byte, []int) { return fileDescriptorGrafeas, []int{9} }

func (m *CreateNoteRequest) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *CreateNoteRequest) GetParent() string {
	if m != nil {
		return m.Parent
	}
	return ""
}

func (m *CreateNoteRequest) GetNoteId() string {
	if m != nil {
		return m.NoteId
	}
	return ""
}

func (m *CreateNoteRequest) GetNote() *Note {
	if m != nil {
		return m.Note
	}
	return nil
}

// Request to update an existing note
type UpdateNoteRequest struct {
	// The name of the note.
	// Should be of the form "projects/{provider_id}/notes/{note_id}".
	Name string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	// The updated note.
	Note *Note `protobuf:"bytes,2,opt,name=note" json:"note,omitempty"`
}

func (m *UpdateNoteRequest) Reset()                    { *m = UpdateNoteRequest{} }
func (m *UpdateNoteRequest) String() string            { return proto.CompactTextString(m) }
func (*UpdateNoteRequest) ProtoMessage()               {}
func (*UpdateNoteRequest) Descriptor() ([]byte, []int) { return fileDescriptorGrafeas, []int{10} }

func (m *UpdateNoteRequest) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *UpdateNoteRequest) GetNote() *Note {
	if m != nil {
		return m.Note
	}
	return nil
}

// Request to list occurrences.
type ListNoteOccurrencesRequest struct {
	// The name field will contain the note name for example:
	//   "provider/{provider_id}/notes/{note_id}"
	Name string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	// The filter expression.
	Filter string `protobuf:"bytes,2,opt,name=filter,proto3" json:"filter,omitempty"`
	// Number of notes to return in the list.
	PageSize int32 `protobuf:"varint,3,opt,name=page_size,json=pageSize,proto3" json:"page_size,omitempty"`
	// Token to provide to skip to a particular spot in the list.
	PageToken string `protobuf:"bytes,4,opt,name=page_token,json=pageToken,proto3" json:"page_token,omitempty"`
}

func (m *ListNoteOccurrencesRequest) Reset()         { *m = ListNoteOccurrencesRequest{} }
func (m *ListNoteOccurrencesRequest) String() string { return proto.CompactTextString(m) }
func (*ListNoteOccurrencesRequest) ProtoMessage()    {}
func (*ListNoteOccurrencesRequest) Descriptor() ([]byte, []int) {
	return fileDescriptorGrafeas, []int{11}
}

func (m *ListNoteOccurrencesRequest) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *ListNoteOccurrencesRequest) GetFilter() string {
	if m != nil {
		return m.Filter
	}
	return ""
}

func (m *ListNoteOccurrencesRequest) GetPageSize() int32 {
	if m != nil {
		return m.PageSize
	}
	return 0
}

func (m *ListNoteOccurrencesRequest) GetPageToken() string {
	if m != nil {
		return m.PageToken
	}
	return ""
}

// Response including listed occurrences for a note.
type ListNoteOccurrencesResponse struct {
	// Token to receive the next page of notes.
	NextPageToken string `protobuf:"bytes,1,opt,name=nextPageToken,proto3" json:"nextPageToken,omitempty"`
	// The occurrences attached to the specified note.
	Occurrences []*Occurrence `protobuf:"bytes,2,rep,name=occurrences" json:"occurrences,omitempty"`
}

func (m *ListNoteOccurrencesResponse) Reset()         { *m = ListNoteOccurrencesResponse{} }
func (m *ListNoteOccurrencesResponse) String() string { return proto.CompactTextString(m) }
func (*ListNoteOccurrencesResponse) ProtoMessage()    {}
func (*ListNoteOccurrencesResponse) Descriptor() ([]byte, []int) {
	return fileDescriptorGrafeas, []int{12}
}

func (m *ListNoteOccurrencesResponse) GetNextPageToken() string {
	if m != nil {
		return m.NextPageToken
	}
	return ""
}

func (m *ListNoteOccurrencesResponse) GetOccurrences() []*Occurrence {
	if m != nil {
		return m.Occurrences
	}
	return nil
}

// Response including listed notes.
type ListNotesResponse struct {
	// The next pagination token in the List response. It should be used as
	// page_token for the following request. An empty value means no more result.
	NextPageToken string `protobuf:"bytes,1,opt,name=nextPageToken,proto3" json:"nextPageToken,omitempty"`
	// The occurrences requested
	Notes []*Note `protobuf:"bytes,2,rep,name=notes" json:"notes,omitempty"`
}

func (m *ListNotesResponse) Reset()                    { *m = ListNotesResponse{} }
func (m *ListNotesResponse) String() string            { return proto.CompactTextString(m) }
func (*ListNotesResponse) ProtoMessage()               {}
func (*ListNotesResponse) Descriptor() ([]byte, []int) { return fileDescriptorGrafeas, []int{13} }

func (m *ListNotesResponse) GetNextPageToken() string {
	if m != nil {
		return m.NextPageToken
	}
	return ""
}

func (m *ListNotesResponse) GetNotes() []*Note {
	if m != nil {
		return m.Notes
	}
	return nil
}

// Response including listed occurrences.
type ListOccurrencesResponse struct {
	// The next pagination token in the List response. It should be used as
	// page_token for the following request. An empty value means no more results.
	NextPageToken string `protobuf:"bytes,1,opt,name=nextPageToken,proto3" json:"nextPageToken,omitempty"`
	// The occurrences requested.
	Occurrences []*Occurrence `protobuf:"bytes,2,rep,name=occurrences" json:"occurrences,omitempty"`
}

func (m *ListOccurrencesResponse) Reset()                    { *m = ListOccurrencesResponse{} }
func (m *ListOccurrencesResponse) String() string            { return proto.CompactTextString(m) }
func (*ListOccurrencesResponse) ProtoMessage()               {}
func (*ListOccurrencesResponse) Descriptor() ([]byte, []int) { return fileDescriptorGrafeas, []int{14} }

func (m *ListOccurrencesResponse) GetNextPageToken() string {
	if m != nil {
		return m.NextPageToken
	}
	return ""
}

func (m *ListOccurrencesResponse) GetOccurrences() []*Occurrence {
	if m != nil {
		return m.Occurrences
	}
	return nil
}

// Response including listed operations.
type ListOperationsResponse struct {
	// The next pagination token in the List response. It should be used as
	// page_token for the following request. An empty value means no more results.
	NextPageToken string `protobuf:"bytes,1,opt,name=nextPageToken,proto3" json:"nextPageToken,omitempty"`
	// The operations requested.
	Operations []*google_longrunning.Operation `protobuf:"bytes,2,rep,name=operations" json:"operations,omitempty"`
}

func (m *ListOperationsResponse) Reset()                    { *m = ListOperationsResponse{} }
func (m *ListOperationsResponse) String() string            { return proto.CompactTextString(m) }
func (*ListOperationsResponse) ProtoMessage()               {}
func (*ListOperationsResponse) Descriptor() ([]byte, []int) { return fileDescriptorGrafeas, []int{15} }

func (m *ListOperationsResponse) GetNextPageToken() string {
	if m != nil {
		return m.NextPageToken
	}
	return ""
}

func (m *ListOperationsResponse) GetOperations() []*google_longrunning.Operation {
	if m != nil {
		return m.Operations
	}
	return nil
}

// Request for updating an existing operation
type UpdateOperationRequest struct {
	// The name of the Operation.
	// Should be of the form "projects/{provider_id}/operations/{operation_id}".
	Name string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	// The operation to create.
	Operation *google_longrunning.Operation `protobuf:"bytes,3,opt,name=operation" json:"operation,omitempty"`
}

func (m *UpdateOperationRequest) Reset()                    { *m = UpdateOperationRequest{} }
func (m *UpdateOperationRequest) String() string            { return proto.CompactTextString(m) }
func (*UpdateOperationRequest) ProtoMessage()               {}
func (*UpdateOperationRequest) Descriptor() ([]byte, []int) { return fileDescriptorGrafeas, []int{16} }

func (m *UpdateOperationRequest) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *UpdateOperationRequest) GetOperation() *google_longrunning.Operation {
	if m != nil {
		return m.Operation
	}
	return nil
}

// Request for creating an operation
type CreateOperationRequest struct {
	// The projectId that this operation should be created under.
	Parent string `protobuf:"bytes,1,opt,name=parent,proto3" json:"parent,omitempty"`
	// The ID to use for this operation.
	OperationId string `protobuf:"bytes,2,opt,name=operation_id,json=operationId,proto3" json:"operation_id,omitempty"`
	// The operation to create.
	Operation *google_longrunning.Operation `protobuf:"bytes,3,opt,name=operation" json:"operation,omitempty"`
}

func (m *CreateOperationRequest) Reset()                    { *m = CreateOperationRequest{} }
func (m *CreateOperationRequest) String() string            { return proto.CompactTextString(m) }
func (*CreateOperationRequest) ProtoMessage()               {}
func (*CreateOperationRequest) Descriptor() ([]byte, []int) { return fileDescriptorGrafeas, []int{17} }

func (m *CreateOperationRequest) GetParent() string {
	if m != nil {
		return m.Parent
	}
	return ""
}

func (m *CreateOperationRequest) GetOperationId() string {
	if m != nil {
		return m.OperationId
	}
	return ""
}

func (m *CreateOperationRequest) GetOperation() *google_longrunning.Operation {
	if m != nil {
		return m.Operation
	}
	return nil
}

// OperationMetadata can be used to provide additional information inside a google.longrunning.operation
type OperationMetadata struct {
	// Output only. The time this operation was created.
	CreateTime *google_protobuf2.Timestamp `protobuf:"bytes,1,opt,name=create_time,json=createTime" json:"create_time,omitempty"`
	// Output only. The time that this operation was marked completed or failed.
	EndTime *google_protobuf2.Timestamp `protobuf:"bytes,2,opt,name=end_time,json=endTime" json:"end_time,omitempty"`
}

func (m *OperationMetadata) Reset()                    { *m = OperationMetadata{} }
func (m *OperationMetadata) String() string            { return proto.CompactTextString(m) }
func (*OperationMetadata) ProtoMessage()               {}
func (*OperationMetadata) Descriptor() ([]byte, []int) { return fileDescriptorGrafeas, []int{18} }

func (m *OperationMetadata) GetCreateTime() *google_protobuf2.Timestamp {
	if m != nil {
		return m.CreateTime
	}
	return nil
}

func (m *OperationMetadata) GetEndTime() *google_protobuf2.Timestamp {
	if m != nil {
		return m.EndTime
	}
	return nil
}

// Artifact describes a build product.
type Artifact struct {
	// Hash or checksum value of a binary, or Docker Registry 2.0 digest of a
	// container.
	Checksum string `protobuf:"bytes,1,opt,name=checksum,proto3" json:"checksum,omitempty"`
	// Artifact ID, if any; for container images, this will be a URL by digest
	// like gcr.io/projectID/imagename@sha256:123456
	Id string `protobuf:"bytes,2,opt,name=id,proto3" json:"id,omitempty"`
	// Related artifact names. This may be the path to a binary or jar file, or in
	// the case of a container build, the name used to push the container image to
	// Google Container Registry, as presented to `docker push`. Note that a
	// single Artifact ID can have multiple names, for example if two tags are
	// applied to one image.
	Names []string `protobuf:"bytes,3,rep,name=names" json:"names,omitempty"`
}

func (m *Artifact) Reset()                    { *m = Artifact{} }
func (m *Artifact) String() string            { return proto.CompactTextString(m) }
func (*Artifact) ProtoMessage()               {}
func (*Artifact) Descriptor() ([]byte, []int) { return fileDescriptorGrafeas, []int{19} }

func (m *Artifact) GetChecksum() string {
	if m != nil {
		return m.Checksum
	}
	return ""
}

func (m *Artifact) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *Artifact) GetNames() []string {
	if m != nil {
		return m.Names
	}
	return nil
}

// Note kind that represents a logical attestation "role" or "authority".  For
// example, an organization might have one AttestationAuthority for "QA" and one
// for "build".  This Note is intended to act strictly as a grouping mechanism
// for the attached Occurrences (Attestations).  This grouping mechanism also
// provides a security boundary, since IAM ACLs gate the ability for a principle
// to attach an Occurrence to a given Note.  It also provides a single point of
// lookup to find all attached Attestation Occurrences, even if they don't all
// live in the same project.
type AttestationAuthority struct {
	Hint *AttestationAuthority_AttestationAuthorityHint `protobuf:"bytes,1,opt,name=hint" json:"hint,omitempty"`
}

func (m *AttestationAuthority) Reset()                    { *m = AttestationAuthority{} }
func (m *AttestationAuthority) String() string            { return proto.CompactTextString(m) }
func (*AttestationAuthority) ProtoMessage()               {}
func (*AttestationAuthority) Descriptor() ([]byte, []int) { return fileDescriptorGrafeas, []int{20} }

func (m *AttestationAuthority) GetHint() *AttestationAuthority_AttestationAuthorityHint {
	if m != nil {
		return m.Hint
	}
	return nil
}

type AttestationAuthority_AttestationAuthorityHint struct {
	// The human readable name of this Attestation Authority, e.g. "qa".
	HumanReadableName string `protobuf:"bytes,1,opt,name=human_readable_name,json=humanReadableName,proto3" json:"human_readable_name,omitempty"`
}

func (m *AttestationAuthority_AttestationAuthorityHint) Reset() {
	*m = AttestationAuthority_AttestationAuthorityHint{}
}
func (m *AttestationAuthority_AttestationAuthorityHint) String() string {
	return proto.CompactTextString(m)
}
func (*AttestationAuthority_AttestationAuthorityHint) ProtoMessage() {}
func (*AttestationAuthority_AttestationAuthorityHint) Descriptor() ([]byte, []int) {
	return fileDescriptorGrafeas, []int{20, 0}
}

func (m *AttestationAuthority_AttestationAuthorityHint) GetHumanReadableName() string {
	if m != nil {
		return m.HumanReadableName
	}
	return ""
}

type AttestationAuthority_Attestation struct {
	// The signature, generally over the `resource_url`, that verifies this
	// attestation.  The semantics of the signature veracity are ultimately
	// determined by the verification engine.
	//
	// Types that are valid to be assigned to Signature:
	//	*AttestationAuthority_Attestation_PgpSignedAttestation
	Signature isAttestationAuthority_Attestation_Signature `protobuf_oneof:"signature"`
}

func (m *AttestationAuthority_Attestation) Reset()         { *m = AttestationAuthority_Attestation{} }
func (m *AttestationAuthority_Attestation) String() string { return proto.CompactTextString(m) }
func (*AttestationAuthority_Attestation) ProtoMessage()    {}
func (*AttestationAuthority_Attestation) Descriptor() ([]byte, []int) {
	return fileDescriptorGrafeas, []int{20, 1}
}

type isAttestationAuthority_Attestation_Signature interface {
	isAttestationAuthority_Attestation_Signature()
	MarshalTo([]byte) (int, error)
	Size() int
}

type AttestationAuthority_Attestation_PgpSignedAttestation struct {
	PgpSignedAttestation *PgpSignedAttestation `protobuf:"bytes,1,opt,name=pgp_signed_attestation,json=pgpSignedAttestation,oneof"`
}

func (*AttestationAuthority_Attestation_PgpSignedAttestation) isAttestationAuthority_Attestation_Signature() {
}

func (m *AttestationAuthority_Attestation) GetSignature() isAttestationAuthority_Attestation_Signature {
	if m != nil {
		return m.Signature
	}
	return nil
}

func (m *AttestationAuthority_Attestation) GetPgpSignedAttestation() *PgpSignedAttestation {
	if x, ok := m.GetSignature().(*AttestationAuthority_Attestation_PgpSignedAttestation); ok {
		return x.PgpSignedAttestation
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*AttestationAuthority_Attestation) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _AttestationAuthority_Attestation_OneofMarshaler, _AttestationAuthority_Attestation_OneofUnmarshaler, _AttestationAuthority_Attestation_OneofSizer, []interface{}{
		(*AttestationAuthority_Attestation_PgpSignedAttestation)(nil),
	}
}

func _AttestationAuthority_Attestation_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*AttestationAuthority_Attestation)
	// signature
	switch x := m.Signature.(type) {
	case *AttestationAuthority_Attestation_PgpSignedAttestation:
		_ = b.EncodeVarint(1<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.PgpSignedAttestation); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("AttestationAuthority_Attestation.Signature has unexpected type %T", x)
	}
	return nil
}

func _AttestationAuthority_Attestation_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*AttestationAuthority_Attestation)
	switch tag {
	case 1: // signature.pgp_signed_attestation
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(PgpSignedAttestation)
		err := b.DecodeMessage(msg)
		m.Signature = &AttestationAuthority_Attestation_PgpSignedAttestation{msg}
		return true, err
	default:
		return false, nil
	}
}

func _AttestationAuthority_Attestation_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*AttestationAuthority_Attestation)
	// signature
	switch x := m.Signature.(type) {
	case *AttestationAuthority_Attestation_PgpSignedAttestation:
		s := proto.Size(x.PgpSignedAttestation)
		n += proto.SizeVarint(1<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

// Message encapsulating build provenance details
type BuildDetails struct {
	// The actual provenance
	Provenance *BuildProvenance `protobuf:"bytes,1,opt,name=provenance" json:"provenance,omitempty"`
	// Serialized json representation of the provenance, used in generating the
	// BuildSignature in the corresponding Result. After verifying the signature,
	// provenance_bytes can be unmarshalled and compared to the provenance to
	// confirm that it is unchanged. A base64-encoded string representation of the
	// provenance bytes is used for the signature in order to interoperate with
	// openssl which expects this format for signature verification.
	//
	// The serialized form is captured both to avoid ambiguity in how the
	// provenance is marshalled to json as well to prevent incompatibilities with
	// future changes.
	ProvenanceBytes string `protobuf:"bytes,2,opt,name=provenance_bytes,json=provenanceBytes,proto3" json:"provenance_bytes,omitempty"`
}

func (m *BuildDetails) Reset()                    { *m = BuildDetails{} }
func (m *BuildDetails) String() string            { return proto.CompactTextString(m) }
func (*BuildDetails) ProtoMessage()               {}
func (*BuildDetails) Descriptor() ([]byte, []int) { return fileDescriptorGrafeas, []int{21} }

func (m *BuildDetails) GetProvenance() *BuildProvenance {
	if m != nil {
		return m.Provenance
	}
	return nil
}

func (m *BuildDetails) GetProvenanceBytes() string {
	if m != nil {
		return m.ProvenanceBytes
	}
	return ""
}

// Provenance of a build. Contains all information needed to verify the full
// details about the build from source to completion.
type BuildProvenance struct {
	// Special options applied to this build. This is a catch-all field where
	// build providers can enter any desired additional details.
	BuildOptions map[string]string `protobuf:"bytes,1,rep,name=build_options,json=buildOptions" json:"build_options,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	// Version string of the builder at the time this build was executed.
	BuilderVersion string `protobuf:"bytes,2,opt,name=builder_version,json=builderVersion,proto3" json:"builder_version,omitempty"`
	// Output of the build.
	BuiltArtifacts []*Artifact `protobuf:"bytes,3,rep,name=built_artifacts,json=builtArtifacts" json:"built_artifacts,omitempty"`
	// Commands requested by the build.
	Commands []*Command `protobuf:"bytes,4,rep,name=commands" json:"commands,omitempty"`
	// Time at which the build was created.
	CreateTime string `protobuf:"bytes,5,opt,name=create_time,json=createTime,proto3" json:"create_time,omitempty"`
	// E-mail address of the user who initiated this build. Note that this was the
	// user's e-mail address at the time the build was initiated; this address may
	// not represent the same end-user for all time.
	Creator string `protobuf:"bytes,6,opt,name=creator,proto3" json:"creator,omitempty"`
	// Time at which execution of the build was finished.
	FinishTime string `protobuf:"bytes,7,opt,name=finish_time,json=finishTime,proto3" json:"finish_time,omitempty"`
	// Unique identifier of the build.
	Id string `protobuf:"bytes,8,opt,name=id,proto3" json:"id,omitempty"`
	// Google Cloud Storage bucket where logs were written.
	LogsBucket string `protobuf:"bytes,9,opt,name=logs_bucket,json=logsBucket,proto3" json:"logs_bucket,omitempty"`
	// ID of the project.
	ProjectId string `protobuf:"bytes,10,opt,name=project_id,json=projectId,proto3" json:"project_id,omitempty"`
	// Numerical ID of the project.
	ProjectNum string `protobuf:"bytes,11,opt,name=project_num,json=projectNum,proto3" json:"project_num,omitempty"`
	// Details of the Source input to the build.
	SourceProvenance *Source `protobuf:"bytes,12,opt,name=source_provenance,json=sourceProvenance" json:"source_provenance,omitempty"`
	// Time at which execution of the build was started.
	StartTime string `protobuf:"bytes,13,opt,name=start_time,json=startTime,proto3" json:"start_time,omitempty"`
	// Trigger identifier if the build was triggered automatically; empty if not.
	TriggerId string `protobuf:"bytes,14,opt,name=trigger_id,json=triggerId,proto3" json:"trigger_id,omitempty"`
}

func (m *BuildProvenance) Reset()                    { *m = BuildProvenance{} }
func (m *BuildProvenance) String() string            { return proto.CompactTextString(m) }
func (*BuildProvenance) ProtoMessage()               {}
func (*BuildProvenance) Descriptor() ([]byte, []int) { return fileDescriptorGrafeas, []int{22} }

func (m *BuildProvenance) GetBuildOptions() map[string]string {
	if m != nil {
		return m.BuildOptions
	}
	return nil
}

func (m *BuildProvenance) GetBuilderVersion() string {
	if m != nil {
		return m.BuilderVersion
	}
	return ""
}

func (m *BuildProvenance) GetBuiltArtifacts() []*Artifact {
	if m != nil {
		return m.BuiltArtifacts
	}
	return nil
}

func (m *BuildProvenance) GetCommands() []*Command {
	if m != nil {
		return m.Commands
	}
	return nil
}

func (m *BuildProvenance) GetCreateTime() string {
	if m != nil {
		return m.CreateTime
	}
	return ""
}

func (m *BuildProvenance) GetCreator() string {
	if m != nil {
		return m.Creator
	}
	return ""
}

func (m *BuildProvenance) GetFinishTime() string {
	if m != nil {
		return m.FinishTime
	}
	return ""
}

func (m *BuildProvenance) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *BuildProvenance) GetLogsBucket() string {
	if m != nil {
		return m.LogsBucket
	}
	return ""
}

func (m *BuildProvenance) GetProjectId() string {
	if m != nil {
		return m.ProjectId
	}
	return ""
}

func (m *BuildProvenance) GetProjectNum() string {
	if m != nil {
		return m.ProjectNum
	}
	return ""
}

func (m *BuildProvenance) GetSourceProvenance() *Source {
	if m != nil {
		return m.SourceProvenance
	}
	return nil
}

func (m *BuildProvenance) GetStartTime() string {
	if m != nil {
		return m.StartTime
	}
	return ""
}

func (m *BuildProvenance) GetTriggerId() string {
	if m != nil {
		return m.TriggerId
	}
	return ""
}

// Message encapsulating signature of the verified build
type BuildSignature struct {
	// An ID for the key used to sign.  This could be either an ID for the key
	// stored in `public_key` (e.g., the ID or fingerprint for a PGP key, or the
	// CN for a cert), or a reference to an external key (e.g., a reference to a
	// key in Cloud KMS).
	KeyId   string                 `protobuf:"bytes,1,opt,name=key_id,json=keyId,proto3" json:"key_id,omitempty"`
	KeyType BuildSignature_KeyType `protobuf:"varint,2,opt,name=key_type,json=keyType,proto3,enum=grafeas.v1alpha1.api.BuildSignature_KeyType" json:"key_type,omitempty"`
	// Public key of the builder which can be used to verify that related
	// Findings are valid and unchanged.  If `key_type` is empty this defaults
	// to PEM encoded public keys.
	//
	// This field may be empty if `key_id` references an external key.
	//
	// For Cloud Container Builder based signatures this is a PEM encoded public
	// key. To verify the Cloud Container Builder signature, place the contents of
	// this field into a file (public.pem). The signature field is base64-decoded
	// into its binary representation in signature.bin, and the provenance bytes
	// from BuildDetails are base64-decoded into a binary representation in
	// signed.bin. OpenSSL can then verify the signature:
	// `openssl sha256 -verify public.pem -signature signature.bin signed.bin`
	PublicKey string `protobuf:"bytes,3,opt,name=public_key,json=publicKey,proto3" json:"public_key,omitempty"`
	// Signature of the related BuildProvenance, encoded in a base64 string.
	Signature string `protobuf:"bytes,4,opt,name=signature,proto3" json:"signature,omitempty"`
}

func (m *BuildSignature) Reset()                    { *m = BuildSignature{} }
func (m *BuildSignature) String() string            { return proto.CompactTextString(m) }
func (*BuildSignature) ProtoMessage()               {}
func (*BuildSignature) Descriptor() ([]byte, []int) { return fileDescriptorGrafeas, []int{23} }

func (m *BuildSignature) GetKeyId() string {
	if m != nil {
		return m.KeyId
	}
	return ""
}

func (m *BuildSignature) GetKeyType() BuildSignature_KeyType {
	if m != nil {
		return m.KeyType
	}
	return BuildSignature_UNSET
}

func (m *BuildSignature) GetPublicKey() string {
	if m != nil {
		return m.PublicKey
	}
	return ""
}

func (m *BuildSignature) GetSignature() string {
	if m != nil {
		return m.Signature
	}
	return ""
}

// Note holding the version of the provider's builder and the signature of
// the provenance message in linked BuildDetails.
type BuildType struct {
	// Version of the builder which produced this Note.
	BuilderVersion string `protobuf:"bytes,1,opt,name=builder_version,json=builderVersion,proto3" json:"builder_version,omitempty"`
	// Signature of the build in Occurrences pointing to the Note containing this
	// BuilderDetails.
	Signature *BuildSignature `protobuf:"bytes,2,opt,name=signature" json:"signature,omitempty"`
}

func (m *BuildType) Reset()                    { *m = BuildType{} }
func (m *BuildType) String() string            { return proto.CompactTextString(m) }
func (*BuildType) ProtoMessage()               {}
func (*BuildType) Descriptor() ([]byte, []int) { return fileDescriptorGrafeas, []int{24} }

func (m *BuildType) GetBuilderVersion() string {
	if m != nil {
		return m.BuilderVersion
	}
	return ""
}

func (m *BuildType) GetSignature() *BuildSignature {
	if m != nil {
		return m.Signature
	}
	return nil
}

// Command describes a step performed as part of the build pipeline.
type Command struct {
	// Command-line arguments used when executing this Command.
	Args []string `protobuf:"bytes,1,rep,name=args" json:"args,omitempty"`
	// Working directory (relative to project source root) used when running
	// this Command.
	Dir string `protobuf:"bytes,2,opt,name=dir,proto3" json:"dir,omitempty"`
	// Environment variables set before running this Command.
	Env []string `protobuf:"bytes,3,rep,name=env" json:"env,omitempty"`
	// Optional unique identifier for this Command, used in wait_for to reference
	// this Command as a dependency.
	Id string `protobuf:"bytes,4,opt,name=id,proto3" json:"id,omitempty"`
	// Name of the command, as presented on the command line, or if the command is
	// packaged as a Docker container, as presented to `docker pull`.
	Name string `protobuf:"bytes,5,opt,name=name,proto3" json:"name,omitempty"`
	// The ID(s) of the Command(s) that this Command depends on.
	WaitFor []string `protobuf:"bytes,6,rep,name=wait_for,json=waitFor" json:"wait_for,omitempty"`
}

func (m *Command) Reset()                    { *m = Command{} }
func (m *Command) String() string            { return proto.CompactTextString(m) }
func (*Command) ProtoMessage()               {}
func (*Command) Descriptor() ([]byte, []int) { return fileDescriptorGrafeas, []int{25} }

func (m *Command) GetArgs() []string {
	if m != nil {
		return m.Args
	}
	return nil
}

func (m *Command) GetDir() string {
	if m != nil {
		return m.Dir
	}
	return ""
}

func (m *Command) GetEnv() []string {
	if m != nil {
		return m.Env
	}
	return nil
}

func (m *Command) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *Command) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *Command) GetWaitFor() []string {
	if m != nil {
		return m.WaitFor
	}
	return nil
}

// An artifact that can be deployed in some runtime.
type Deployable struct {
	// Resource URI for the artifact being deployed.
	ResourceUri []string `protobuf:"bytes,1,rep,name=resource_uri,json=resourceUri" json:"resource_uri,omitempty"`
}

func (m *Deployable) Reset()                    { *m = Deployable{} }
func (m *Deployable) String() string            { return proto.CompactTextString(m) }
func (*Deployable) ProtoMessage()               {}
func (*Deployable) Descriptor() ([]byte, []int) { return fileDescriptorGrafeas, []int{26} }

func (m *Deployable) GetResourceUri() []string {
	if m != nil {
		return m.ResourceUri
	}
	return nil
}

// The period during which some deployable was active in a runtime.
type Deployable_Deployment struct {
	// Address of the runtime element hosting this deployment.
	Address string `protobuf:"bytes,1,opt,name=address,proto3" json:"address,omitempty"`
	// Configuration used to create this deployment.
	Config map[string]string `protobuf:"bytes,2,rep,name=config" json:"config,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	// Beginning of the lifetime of this deployment.
	DeployTime string `protobuf:"bytes,3,opt,name=deploy_time,json=deployTime,proto3" json:"deploy_time,omitempty"`
	// End of the lifetime of this deployment.
	UndeployTime string `protobuf:"bytes,4,opt,name=undeploy_time,json=undeployTime,proto3" json:"undeploy_time,omitempty"`
	// Identity of the user that triggered this deployment.
	UserEmail string `protobuf:"bytes,5,opt,name=user_email,json=userEmail,proto3" json:"user_email,omitempty"`
}

func (m *Deployable_Deployment) Reset()                    { *m = Deployable_Deployment{} }
func (m *Deployable_Deployment) String() string            { return proto.CompactTextString(m) }
func (*Deployable_Deployment) ProtoMessage()               {}
func (*Deployable_Deployment) Descriptor() ([]byte, []int) { return fileDescriptorGrafeas, []int{26, 0} }

func (m *Deployable_Deployment) GetAddress() string {
	if m != nil {
		return m.Address
	}
	return ""
}

func (m *Deployable_Deployment) GetConfig() map[string]string {
	if m != nil {
		return m.Config
	}
	return nil
}

func (m *Deployable_Deployment) GetDeployTime() string {
	if m != nil {
		return m.DeployTime
	}
	return ""
}

func (m *Deployable_Deployment) GetUndeployTime() string {
	if m != nil {
		return m.UndeployTime
	}
	return ""
}

func (m *Deployable_Deployment) GetUserEmail() string {
	if m != nil {
		return m.UserEmail
	}
	return ""
}

// DockerImage holds types defining base image notes
// and derived image occurrences.
type DockerImage struct {
}

func (m *DockerImage) Reset()                    { *m = DockerImage{} }
func (m *DockerImage) String() string            { return proto.CompactTextString(m) }
func (*DockerImage) ProtoMessage()               {}
func (*DockerImage) Descriptor() ([]byte, []int) { return fileDescriptorGrafeas, []int{27} }

// Instructions from dockerfile
type DockerImage_Layer struct {
	// The recovered arguments to the Dockerfile directive.
	Arguments string                      `protobuf:"bytes,1,opt,name=arguments,proto3" json:"arguments,omitempty"`
	Directive DockerImage_Layer_Directive `protobuf:"varint,2,opt,name=directive,proto3,enum=grafeas.v1alpha1.api.DockerImage_Layer_Directive" json:"directive,omitempty"`
}

func (m *DockerImage_Layer) Reset()                    { *m = DockerImage_Layer{} }
func (m *DockerImage_Layer) String() string            { return proto.CompactTextString(m) }
func (*DockerImage_Layer) ProtoMessage()               {}
func (*DockerImage_Layer) Descriptor() ([]byte, []int) { return fileDescriptorGrafeas, []int{27, 0} }

func (m *DockerImage_Layer) GetArguments() string {
	if m != nil {
		return m.Arguments
	}
	return ""
}

func (m *DockerImage_Layer) GetDirective() DockerImage_Layer_Directive {
	if m != nil {
		return m.Directive
	}
	return DockerImage_Layer_UNKNOWN_DIRECTIVE
}

// A set of properties that uniquely identify a given Docker image.
type DockerImage_Fingerprint struct {
	// The layer-id of the final layer in the Docker images v1
	// representation.
	// This field can be used as a filter in list requests.
	V1Name string `protobuf:"bytes,1,opt,name=v1_name,json=v1Name,proto3" json:"v1_name,omitempty"`
	// The ordered list of v2 blobs that represent a given image.
	V2Blob []string `protobuf:"bytes,2,rep,name=v2_blob,json=v2Blob" json:"v2_blob,omitempty"`
	// The name of the images v2 blobs computed via:
	//   [bottom] := v2_blobbottom := sha256(v2_blob[N] +   + v2_name[N+1])
	// Only the name of the final blob is kept.
	// This field can be used as a filter in list requests.
	// @OutputOnly
	V2Name string `protobuf:"bytes,3,opt,name=v2_name,json=v2Name,proto3" json:"v2_name,omitempty"`
}

func (m *DockerImage_Fingerprint) Reset()         { *m = DockerImage_Fingerprint{} }
func (m *DockerImage_Fingerprint) String() string { return proto.CompactTextString(m) }
func (*DockerImage_Fingerprint) ProtoMessage()    {}
func (*DockerImage_Fingerprint) Descriptor() ([]byte, []int) {
	return fileDescriptorGrafeas, []int{27, 1}
}

func (m *DockerImage_Fingerprint) GetV1Name() string {
	if m != nil {
		return m.V1Name
	}
	return ""
}

func (m *DockerImage_Fingerprint) GetV2Blob() []string {
	if m != nil {
		return m.V2Blob
	}
	return nil
}

func (m *DockerImage_Fingerprint) GetV2Name() string {
	if m != nil {
		return m.V2Name
	}
	return ""
}

// Basis describes the base image portion (Note) of the DockerImage
// relationship.  Linked occurrences are derived from this or an
// equivalent image via:
//   FROM <Basis.resource_url>
// Or an equivalent reference, e.g. a tag of the resource_url.
type DockerImage_Basis struct {
	// The fingerprint of the base image
	Fingerprint *DockerImage_Fingerprint `protobuf:"bytes,1,opt,name=fingerprint" json:"fingerprint,omitempty"`
	// The resource_url for the resource representing the basis of
	// associated occurrence images.
	ResourceUrl string `protobuf:"bytes,2,opt,name=resource_url,json=resourceUrl,proto3" json:"resource_url,omitempty"`
}

func (m *DockerImage_Basis) Reset()                    { *m = DockerImage_Basis{} }
func (m *DockerImage_Basis) String() string            { return proto.CompactTextString(m) }
func (*DockerImage_Basis) ProtoMessage()               {}
func (*DockerImage_Basis) Descriptor() ([]byte, []int) { return fileDescriptorGrafeas, []int{27, 2} }

func (m *DockerImage_Basis) GetFingerprint() *DockerImage_Fingerprint {
	if m != nil {
		return m.Fingerprint
	}
	return nil
}

func (m *DockerImage_Basis) GetResourceUrl() string {
	if m != nil {
		return m.ResourceUrl
	}
	return ""
}

// Derived describes the derived image portion (Occurrence) of the
// DockerImage relationship.  This image would be produced from a Dockerfile
// with FROM <DockerImage.Basis in attached Note>.
type DockerImage_Derived struct {
	// This contains the base image url for the derived image Occurrence
	// @OutputOnly
	BaseResourceUrl string `protobuf:"bytes,1,opt,name=base_resource_url,json=baseResourceUrl,proto3" json:"base_resource_url,omitempty"`
	// The number of layers by which this image differs from
	// the associated image basis.
	// @OutputOnly
	Distance uint32 `protobuf:"varint,2,opt,name=distance,proto3" json:"distance,omitempty"`
	// The fingerprint of the derived image
	Fingerprint *DockerImage_Fingerprint `protobuf:"bytes,3,opt,name=fingerprint" json:"fingerprint,omitempty"`
	// This contains layer-specific metadata, if populated it
	// has length distance and is ordered with [distance] being the
	// layer immediately following the base image and [1]
	// being the final layer.
	LayerInfo []*DockerImage_Layer `protobuf:"bytes,4,rep,name=layer_info,json=layerInfo" json:"layer_info,omitempty"`
}

func (m *DockerImage_Derived) Reset()                    { *m = DockerImage_Derived{} }
func (m *DockerImage_Derived) String() string            { return proto.CompactTextString(m) }
func (*DockerImage_Derived) ProtoMessage()               {}
func (*DockerImage_Derived) Descriptor() ([]byte, []int) { return fileDescriptorGrafeas, []int{27, 3} }

func (m *DockerImage_Derived) GetBaseResourceUrl() string {
	if m != nil {
		return m.BaseResourceUrl
	}
	return ""
}

func (m *DockerImage_Derived) GetDistance() uint32 {
	if m != nil {
		return m.Distance
	}
	return 0
}

func (m *DockerImage_Derived) GetFingerprint() *DockerImage_Fingerprint {
	if m != nil {
		return m.Fingerprint
	}
	return nil
}

func (m *DockerImage_Derived) GetLayerInfo() []*DockerImage_Layer {
	if m != nil {
		return m.LayerInfo
	}
	return nil
}

// Note that indicates a type of analysis and exists in a provider project to
// indicate the status of an analysis on a resource. Absence of an occurrence
// linked to this note for a resource indicates that analysis hasn't started.
type Discovery struct {
	// The kind of analysis that is handled by this discovery.
	AnalysisKind Note_Kind `protobuf:"varint,1,opt,name=analysis_kind,json=analysisKind,proto3,enum=grafeas.v1alpha1.api.Note_Kind" json:"analysis_kind,omitempty"`
}

func (m *Discovery) Reset()                    { *m = Discovery{} }
func (m *Discovery) String() string            { return proto.CompactTextString(m) }
func (*Discovery) ProtoMessage()               {}
func (*Discovery) Descriptor() ([]byte, []int) { return fileDescriptorGrafeas, []int{28} }

func (m *Discovery) GetAnalysisKind() Note_Kind {
	if m != nil {
		return m.AnalysisKind
	}
	return Note_KIND_UNSPECIFIED
}

type Discovery_Discovered struct {
	// An operation that indicates the status of the current scan.
	// @OutputOnly
	Operation *google_longrunning.Operation `protobuf:"bytes,1,opt,name=operation" json:"operation,omitempty"`
}

func (m *Discovery_Discovered) Reset()                    { *m = Discovery_Discovered{} }
func (m *Discovery_Discovered) String() string            { return proto.CompactTextString(m) }
func (*Discovery_Discovered) ProtoMessage()               {}
func (*Discovery_Discovered) Descriptor() ([]byte, []int) { return fileDescriptorGrafeas, []int{28, 0} }

func (m *Discovery_Discovered) GetOperation() *google_longrunning.Operation {
	if m != nil {
		return m.Operation
	}
	return nil
}

// Container message for hashes of byte content of files, used in Source
// messages to verify integrity of source input to the build.
type FileHashes struct {
	// Collection of file hashes.
	FileHash []*Hash `protobuf:"bytes,1,rep,name=file_hash,json=fileHash" json:"file_hash,omitempty"`
}

func (m *FileHashes) Reset()                    { *m = FileHashes{} }
func (m *FileHashes) String() string            { return proto.CompactTextString(m) }
func (*FileHashes) ProtoMessage()               {}
func (*FileHashes) Descriptor() ([]byte, []int) { return fileDescriptorGrafeas, []int{29} }

func (m *FileHashes) GetFileHash() []*Hash {
	if m != nil {
		return m.FileHash
	}
	return nil
}

// Container message for hash values.
type Hash struct {
	Type Hash_Type `protobuf:"varint,1,opt,name=type,proto3,enum=grafeas.v1alpha1.api.Hash_Type" json:"type,omitempty"`
	// The hash value.
	Value string `protobuf:"bytes,2,opt,name=value,proto3" json:"value,omitempty"`
}

func (m *Hash) Reset()                    { *m = Hash{} }
func (m *Hash) String() string            { return proto.CompactTextString(m) }
func (*Hash) ProtoMessage()               {}
func (*Hash) Descriptor() ([]byte, []int) { return fileDescriptorGrafeas, []int{30} }

func (m *Hash) GetType() Hash_Type {
	if m != nil {
		return m.Type
	}
	return Hash_NONE
}

func (m *Hash) GetValue() string {
	if m != nil {
		return m.Value
	}
	return ""
}

// Note provides a detailed description of a note using information
// from the provider of the note.
type Note struct {
	// The name of the note in the form
	// "providers/{provider_id}/notes/{note_id}"
	Name string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	// A one sentence description of this note
	ShortDescription string `protobuf:"bytes,3,opt,name=short_description,json=shortDescription,proto3" json:"short_description,omitempty"`
	// A detailed description of this note
	LongDescription string `protobuf:"bytes,4,opt,name=long_description,json=longDescription,proto3" json:"long_description,omitempty"`
	// Output only. This explicitly denotes which kind of note is specified. This
	// field can be used as a filter in list requests.
	Kind Note_Kind `protobuf:"varint,9,opt,name=kind,proto3,enum=grafeas.v1alpha1.api.Note_Kind" json:"kind,omitempty"`
	// The type of note.
	//
	// Types that are valid to be assigned to NoteType:
	//	*Note_VulnerabilityType
	//	*Note_BuildType
	//	*Note_BaseImage
	//	*Note_Package
	//	*Note_Deployable
	//	*Note_Discovery
	//	*Note_AttestationAuthority
	NoteType isNote_NoteType `protobuf_oneof:"note_type"`
	// Urls associated with this note
	RelatedUrl []*Note_RelatedUrl `protobuf:"bytes,7,rep,name=related_url,json=relatedUrl" json:"related_url,omitempty"`
	// Time of expiration for this note, null if note currently does not expire.
	ExpirationTime *google_protobuf2.Timestamp `protobuf:"bytes,10,opt,name=expiration_time,json=expirationTime" json:"expiration_time,omitempty"`
	// Output only. The time this note was created. This field can be used as a
	// filter in list requests.
	CreateTime *google_protobuf2.Timestamp `protobuf:"bytes,11,opt,name=create_time,json=createTime" json:"create_time,omitempty"`
	// Output only. The time this note was last updated. This field can be used as
	// a filter in list requests.
	UpdateTime *google_protobuf2.Timestamp `protobuf:"bytes,12,opt,name=update_time,json=updateTime" json:"update_time,omitempty"`
	// The name of the operation that created this note.
	OperationName string `protobuf:"bytes,15,opt,name=operation_name,json=operationName,proto3" json:"operation_name,omitempty"`
}

func (m *Note) Reset()                    { *m = Note{} }
func (m *Note) String() string            { return proto.CompactTextString(m) }
func (*Note) ProtoMessage()               {}
func (*Note) Descriptor() ([]byte, []int) { return fileDescriptorGrafeas, []int{31} }

type isNote_NoteType interface {
	isNote_NoteType()
	MarshalTo([]byte) (int, error)
	Size() int
}

type Note_VulnerabilityType struct {
	VulnerabilityType *VulnerabilityType `protobuf:"bytes,6,opt,name=vulnerability_type,json=vulnerabilityType,oneof"`
}
type Note_BuildType struct {
	BuildType *BuildType `protobuf:"bytes,8,opt,name=build_type,json=buildType,oneof"`
}
type Note_BaseImage struct {
	BaseImage *DockerImage_Basis `protobuf:"bytes,13,opt,name=base_image,json=baseImage,oneof"`
}
type Note_Package struct {
	Package *PackageManager_Package `protobuf:"bytes,14,opt,name=package,oneof"`
}
type Note_Deployable struct {
	Deployable *Deployable `protobuf:"bytes,17,opt,name=deployable,oneof"`
}
type Note_Discovery struct {
	Discovery *Discovery `protobuf:"bytes,18,opt,name=discovery,oneof"`
}
type Note_AttestationAuthority struct {
	AttestationAuthority *AttestationAuthority `protobuf:"bytes,19,opt,name=attestation_authority,json=attestationAuthority,oneof"`
}

func (*Note_VulnerabilityType) isNote_NoteType()    {}
func (*Note_BuildType) isNote_NoteType()            {}
func (*Note_BaseImage) isNote_NoteType()            {}
func (*Note_Package) isNote_NoteType()              {}
func (*Note_Deployable) isNote_NoteType()           {}
func (*Note_Discovery) isNote_NoteType()            {}
func (*Note_AttestationAuthority) isNote_NoteType() {}

func (m *Note) GetNoteType() isNote_NoteType {
	if m != nil {
		return m.NoteType
	}
	return nil
}

func (m *Note) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *Note) GetShortDescription() string {
	if m != nil {
		return m.ShortDescription
	}
	return ""
}

func (m *Note) GetLongDescription() string {
	if m != nil {
		return m.LongDescription
	}
	return ""
}

func (m *Note) GetKind() Note_Kind {
	if m != nil {
		return m.Kind
	}
	return Note_KIND_UNSPECIFIED
}

func (m *Note) GetVulnerabilityType() *VulnerabilityType {
	if x, ok := m.GetNoteType().(*Note_VulnerabilityType); ok {
		return x.VulnerabilityType
	}
	return nil
}

func (m *Note) GetBuildType() *BuildType {
	if x, ok := m.GetNoteType().(*Note_BuildType); ok {
		return x.BuildType
	}
	return nil
}

func (m *Note) GetBaseImage() *DockerImage_Basis {
	if x, ok := m.GetNoteType().(*Note_BaseImage); ok {
		return x.BaseImage
	}
	return nil
}

func (m *Note) GetPackage() *PackageManager_Package {
	if x, ok := m.GetNoteType().(*Note_Package); ok {
		return x.Package
	}
	return nil
}

func (m *Note) GetDeployable() *Deployable {
	if x, ok := m.GetNoteType().(*Note_Deployable); ok {
		return x.Deployable
	}
	return nil
}

func (m *Note) GetDiscovery() *Discovery {
	if x, ok := m.GetNoteType().(*Note_Discovery); ok {
		return x.Discovery
	}
	return nil
}

func (m *Note) GetAttestationAuthority() *AttestationAuthority {
	if x, ok := m.GetNoteType().(*Note_AttestationAuthority); ok {
		return x.AttestationAuthority
	}
	return nil
}

func (m *Note) GetRelatedUrl() []*Note_RelatedUrl {
	if m != nil {
		return m.RelatedUrl
	}
	return nil
}

func (m *Note) GetExpirationTime() *google_protobuf2.Timestamp {
	if m != nil {
		return m.ExpirationTime
	}
	return nil
}

func (m *Note) GetCreateTime() *google_protobuf2.Timestamp {
	if m != nil {
		return m.CreateTime
	}
	return nil
}

func (m *Note) GetUpdateTime() *google_protobuf2.Timestamp {
	if m != nil {
		return m.UpdateTime
	}
	return nil
}

func (m *Note) GetOperationName() string {
	if m != nil {
		return m.OperationName
	}
	return ""
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*Note) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _Note_OneofMarshaler, _Note_OneofUnmarshaler, _Note_OneofSizer, []interface{}{
		(*Note_VulnerabilityType)(nil),
		(*Note_BuildType)(nil),
		(*Note_BaseImage)(nil),
		(*Note_Package)(nil),
		(*Note_Deployable)(nil),
		(*Note_Discovery)(nil),
		(*Note_AttestationAuthority)(nil),
	}
}

func _Note_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*Note)
	// note_type
	switch x := m.NoteType.(type) {
	case *Note_VulnerabilityType:
		_ = b.EncodeVarint(6<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.VulnerabilityType); err != nil {
			return err
		}
	case *Note_BuildType:
		_ = b.EncodeVarint(8<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.BuildType); err != nil {
			return err
		}
	case *Note_BaseImage:
		_ = b.EncodeVarint(13<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.BaseImage); err != nil {
			return err
		}
	case *Note_Package:
		_ = b.EncodeVarint(14<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Package); err != nil {
			return err
		}
	case *Note_Deployable:
		_ = b.EncodeVarint(17<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Deployable); err != nil {
			return err
		}
	case *Note_Discovery:
		_ = b.EncodeVarint(18<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Discovery); err != nil {
			return err
		}
	case *Note_AttestationAuthority:
		_ = b.EncodeVarint(19<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.AttestationAuthority); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("Note.NoteType has unexpected type %T", x)
	}
	return nil
}

func _Note_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*Note)
	switch tag {
	case 6: // note_type.vulnerability_type
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(VulnerabilityType)
		err := b.DecodeMessage(msg)
		m.NoteType = &Note_VulnerabilityType{msg}
		return true, err
	case 8: // note_type.build_type
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(BuildType)
		err := b.DecodeMessage(msg)
		m.NoteType = &Note_BuildType{msg}
		return true, err
	case 13: // note_type.base_image
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(DockerImage_Basis)
		err := b.DecodeMessage(msg)
		m.NoteType = &Note_BaseImage{msg}
		return true, err
	case 14: // note_type.package
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(PackageManager_Package)
		err := b.DecodeMessage(msg)
		m.NoteType = &Note_Package{msg}
		return true, err
	case 17: // note_type.deployable
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(Deployable)
		err := b.DecodeMessage(msg)
		m.NoteType = &Note_Deployable{msg}
		return true, err
	case 18: // note_type.discovery
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(Discovery)
		err := b.DecodeMessage(msg)
		m.NoteType = &Note_Discovery{msg}
		return true, err
	case 19: // note_type.attestation_authority
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(AttestationAuthority)
		err := b.DecodeMessage(msg)
		m.NoteType = &Note_AttestationAuthority{msg}
		return true, err
	default:
		return false, nil
	}
}

func _Note_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*Note)
	// note_type
	switch x := m.NoteType.(type) {
	case *Note_VulnerabilityType:
		s := proto.Size(x.VulnerabilityType)
		n += proto.SizeVarint(6<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *Note_BuildType:
		s := proto.Size(x.BuildType)
		n += proto.SizeVarint(8<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *Note_BaseImage:
		s := proto.Size(x.BaseImage)
		n += proto.SizeVarint(13<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *Note_Package:
		s := proto.Size(x.Package)
		n += proto.SizeVarint(14<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *Note_Deployable:
		s := proto.Size(x.Deployable)
		n += proto.SizeVarint(17<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *Note_Discovery:
		s := proto.Size(x.Discovery)
		n += proto.SizeVarint(18<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *Note_AttestationAuthority:
		s := proto.Size(x.AttestationAuthority)
		n += proto.SizeVarint(19<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

// Metadata for any related url information
type Note_RelatedUrl struct {
	// Specific url to associate with the note
	Url string `protobuf:"bytes,1,opt,name=url,proto3" json:"url,omitempty"`
	// Label to describe usage of the url
	Label string `protobuf:"bytes,2,opt,name=label,proto3" json:"label,omitempty"`
}

func (m *Note_RelatedUrl) Reset()                    { *m = Note_RelatedUrl{} }
func (m *Note_RelatedUrl) String() string            { return proto.CompactTextString(m) }
func (*Note_RelatedUrl) ProtoMessage()               {}
func (*Note_RelatedUrl) Descriptor() ([]byte, []int) { return fileDescriptorGrafeas, []int{31, 0} }

func (m *Note_RelatedUrl) GetUrl() string {
	if m != nil {
		return m.Url
	}
	return ""
}

func (m *Note_RelatedUrl) GetLabel() string {
	if m != nil {
		return m.Label
	}
	return ""
}

// Occurrence includes information about analysis occurrences for an image.
type Occurrence struct {
	// Output only. The name of the occurrence in the form
	// "projects/{project_id}/occurrences/{occurrence_id}"
	Name string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	// The unique url of the image or container for which the occurrence applies.
	// Example: https://gcr.io/project/image@sha256:foo
	// This field can be used as a filter in list requests.
	ResourceUrl string `protobuf:"bytes,2,opt,name=resource_url,json=resourceUrl,proto3" json:"resource_url,omitempty"`
	// An analysis note associated with this image, in the form
	// "providers/{provider_id}/notes/{note_id}"
	// This field can be used as a filter in list requests.
	NoteName string `protobuf:"bytes,3,opt,name=note_name,json=noteName,proto3" json:"note_name,omitempty"`
	// Output only. This explicitly denotes which of the occurrence details is
	// specified. This field can be used as a filter in list requests.
	Kind Note_Kind `protobuf:"varint,6,opt,name=kind,proto3,enum=grafeas.v1alpha1.api.Note_Kind" json:"kind,omitempty"`
	// Describes the details of the vulnerability note found in this resource.
	//
	// Types that are valid to be assigned to Details:
	//	*Occurrence_VulnerabilityDetails
	//	*Occurrence_BuildDetails
	//	*Occurrence_DerivedImage
	//	*Occurrence_Installation
	//	*Occurrence_Deployment
	//	*Occurrence_Discovered
	//	*Occurrence_Attestation
	Details isOccurrence_Details `protobuf_oneof:"details"`
	// A description of actions that can be taken to remedy the note
	Remediation string `protobuf:"bytes,5,opt,name=remediation,proto3" json:"remediation,omitempty"`
	// Output only. The time this occurrence was created.
	CreateTime *google_protobuf2.Timestamp `protobuf:"bytes,9,opt,name=create_time,json=createTime" json:"create_time,omitempty"`
	// Output only. The time this occurrence was last updated.
	UpdateTime *google_protobuf2.Timestamp `protobuf:"bytes,10,opt,name=update_time,json=updateTime" json:"update_time,omitempty"`
	// The name of the operation that created this note.
	OperationName string `protobuf:"bytes,13,opt,name=operation_name,json=operationName,proto3" json:"operation_name,omitempty"`
}

func (m *Occurrence) Reset()                    { *m = Occurrence{} }
func (m *Occurrence) String() string            { return proto.CompactTextString(m) }
func (*Occurrence) ProtoMessage()               {}
func (*Occurrence) Descriptor() ([]byte, []int) { return fileDescriptorGrafeas, []int{32} }

type isOccurrence_Details interface {
	isOccurrence_Details()
	MarshalTo([]byte) (int, error)
	Size() int
}

type Occurrence_VulnerabilityDetails struct {
	VulnerabilityDetails *VulnerabilityType_VulnerabilityDetails `protobuf:"bytes,8,opt,name=vulnerability_details,json=vulnerabilityDetails,oneof"`
}
type Occurrence_BuildDetails struct {
	BuildDetails *BuildDetails `protobuf:"bytes,7,opt,name=build_details,json=buildDetails,oneof"`
}
type Occurrence_DerivedImage struct {
	DerivedImage *DockerImage_Derived `protobuf:"bytes,11,opt,name=derived_image,json=derivedImage,oneof"`
}
type Occurrence_Installation struct {
	Installation *PackageManager_Installation `protobuf:"bytes,12,opt,name=installation,oneof"`
}
type Occurrence_Deployment struct {
	Deployment *Deployable_Deployment `protobuf:"bytes,14,opt,name=deployment,oneof"`
}
type Occurrence_Discovered struct {
	Discovered *Discovery_Discovered `protobuf:"bytes,15,opt,name=discovered,oneof"`
}
type Occurrence_Attestation struct {
	Attestation *AttestationAuthority_Attestation `protobuf:"bytes,16,opt,name=attestation,oneof"`
}

func (*Occurrence_VulnerabilityDetails) isOccurrence_Details() {}
func (*Occurrence_BuildDetails) isOccurrence_Details()         {}
func (*Occurrence_DerivedImage) isOccurrence_Details()         {}
func (*Occurrence_Installation) isOccurrence_Details()         {}
func (*Occurrence_Deployment) isOccurrence_Details()           {}
func (*Occurrence_Discovered) isOccurrence_Details()           {}
func (*Occurrence_Attestation) isOccurrence_Details()          {}

func (m *Occurrence) GetDetails() isOccurrence_Details {
	if m != nil {
		return m.Details
	}
	return nil
}

func (m *Occurrence) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *Occurrence) GetResourceUrl() string {
	if m != nil {
		return m.ResourceUrl
	}
	return ""
}

func (m *Occurrence) GetNoteName() string {
	if m != nil {
		return m.NoteName
	}
	return ""
}

func (m *Occurrence) GetKind() Note_Kind {
	if m != nil {
		return m.Kind
	}
	return Note_KIND_UNSPECIFIED
}

func (m *Occurrence) GetVulnerabilityDetails() *VulnerabilityType_VulnerabilityDetails {
	if x, ok := m.GetDetails().(*Occurrence_VulnerabilityDetails); ok {
		return x.VulnerabilityDetails
	}
	return nil
}

func (m *Occurrence) GetBuildDetails() *BuildDetails {
	if x, ok := m.GetDetails().(*Occurrence_BuildDetails); ok {
		return x.BuildDetails
	}
	return nil
}

func (m *Occurrence) GetDerivedImage() *DockerImage_Derived {
	if x, ok := m.GetDetails().(*Occurrence_DerivedImage); ok {
		return x.DerivedImage
	}
	return nil
}

func (m *Occurrence) GetInstallation() *PackageManager_Installation {
	if x, ok := m.GetDetails().(*Occurrence_Installation); ok {
		return x.Installation
	}
	return nil
}

func (m *Occurrence) GetDeployment() *Deployable_Deployment {
	if x, ok := m.GetDetails().(*Occurrence_Deployment); ok {
		return x.Deployment
	}
	return nil
}

func (m *Occurrence) GetDiscovered() *Discovery_Discovered {
	if x, ok := m.GetDetails().(*Occurrence_Discovered); ok {
		return x.Discovered
	}
	return nil
}

func (m *Occurrence) GetAttestation() *AttestationAuthority_Attestation {
	if x, ok := m.GetDetails().(*Occurrence_Attestation); ok {
		return x.Attestation
	}
	return nil
}

func (m *Occurrence) GetRemediation() string {
	if m != nil {
		return m.Remediation
	}
	return ""
}

func (m *Occurrence) GetCreateTime() *google_protobuf2.Timestamp {
	if m != nil {
		return m.CreateTime
	}
	return nil
}

func (m *Occurrence) GetUpdateTime() *google_protobuf2.Timestamp {
	if m != nil {
		return m.UpdateTime
	}
	return nil
}

func (m *Occurrence) GetOperationName() string {
	if m != nil {
		return m.OperationName
	}
	return ""
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*Occurrence) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _Occurrence_OneofMarshaler, _Occurrence_OneofUnmarshaler, _Occurrence_OneofSizer, []interface{}{
		(*Occurrence_VulnerabilityDetails)(nil),
		(*Occurrence_BuildDetails)(nil),
		(*Occurrence_DerivedImage)(nil),
		(*Occurrence_Installation)(nil),
		(*Occurrence_Deployment)(nil),
		(*Occurrence_Discovered)(nil),
		(*Occurrence_Attestation)(nil),
	}
}

func _Occurrence_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*Occurrence)
	// details
	switch x := m.Details.(type) {
	case *Occurrence_VulnerabilityDetails:
		_ = b.EncodeVarint(8<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.VulnerabilityDetails); err != nil {
			return err
		}
	case *Occurrence_BuildDetails:
		_ = b.EncodeVarint(7<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.BuildDetails); err != nil {
			return err
		}
	case *Occurrence_DerivedImage:
		_ = b.EncodeVarint(11<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.DerivedImage); err != nil {
			return err
		}
	case *Occurrence_Installation:
		_ = b.EncodeVarint(12<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Installation); err != nil {
			return err
		}
	case *Occurrence_Deployment:
		_ = b.EncodeVarint(14<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Deployment); err != nil {
			return err
		}
	case *Occurrence_Discovered:
		_ = b.EncodeVarint(15<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Discovered); err != nil {
			return err
		}
	case *Occurrence_Attestation:
		_ = b.EncodeVarint(16<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Attestation); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("Occurrence.Details has unexpected type %T", x)
	}
	return nil
}

func _Occurrence_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*Occurrence)
	switch tag {
	case 8: // details.vulnerability_details
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(VulnerabilityType_VulnerabilityDetails)
		err := b.DecodeMessage(msg)
		m.Details = &Occurrence_VulnerabilityDetails{msg}
		return true, err
	case 7: // details.build_details
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(BuildDetails)
		err := b.DecodeMessage(msg)
		m.Details = &Occurrence_BuildDetails{msg}
		return true, err
	case 11: // details.derived_image
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(DockerImage_Derived)
		err := b.DecodeMessage(msg)
		m.Details = &Occurrence_DerivedImage{msg}
		return true, err
	case 12: // details.installation
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(PackageManager_Installation)
		err := b.DecodeMessage(msg)
		m.Details = &Occurrence_Installation{msg}
		return true, err
	case 14: // details.deployment
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(Deployable_Deployment)
		err := b.DecodeMessage(msg)
		m.Details = &Occurrence_Deployment{msg}
		return true, err
	case 15: // details.discovered
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(Discovery_Discovered)
		err := b.DecodeMessage(msg)
		m.Details = &Occurrence_Discovered{msg}
		return true, err
	case 16: // details.attestation
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(AttestationAuthority_Attestation)
		err := b.DecodeMessage(msg)
		m.Details = &Occurrence_Attestation{msg}
		return true, err
	default:
		return false, nil
	}
}

func _Occurrence_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*Occurrence)
	// details
	switch x := m.Details.(type) {
	case *Occurrence_VulnerabilityDetails:
		s := proto.Size(x.VulnerabilityDetails)
		n += proto.SizeVarint(8<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *Occurrence_BuildDetails:
		s := proto.Size(x.BuildDetails)
		n += proto.SizeVarint(7<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *Occurrence_DerivedImage:
		s := proto.Size(x.DerivedImage)
		n += proto.SizeVarint(11<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *Occurrence_Installation:
		s := proto.Size(x.Installation)
		n += proto.SizeVarint(12<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *Occurrence_Deployment:
		s := proto.Size(x.Deployment)
		n += proto.SizeVarint(14<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *Occurrence_Discovered:
		s := proto.Size(x.Discovered)
		n += proto.SizeVarint(15<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *Occurrence_Attestation:
		s := proto.Size(x.Attestation)
		n += proto.SizeVarint(16<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

// PackageManager provides metadata about available / installed packages.
type PackageManager struct {
}

func (m *PackageManager) Reset()                    { *m = PackageManager{} }
func (m *PackageManager) String() string            { return proto.CompactTextString(m) }
func (*PackageManager) ProtoMessage()               {}
func (*PackageManager) Descriptor() ([]byte, []int) { return fileDescriptorGrafeas, []int{33} }

// This represents a particular package that is distributed over
// various channels.
// e.g. glibc (aka libc6) is distributed by many, at various versions.
type PackageManager_Package struct {
	// The various channels by which a package is distributed.
	Distribution []*PackageManager_Distribution `protobuf:"bytes,1,rep,name=distribution" json:"distribution,omitempty"`
	// The name of the package.
	Name string `protobuf:"bytes,2,opt,name=name,proto3" json:"name,omitempty"`
}

func (m *PackageManager_Package) Reset()         { *m = PackageManager_Package{} }
func (m *PackageManager_Package) String() string { return proto.CompactTextString(m) }
func (*PackageManager_Package) ProtoMessage()    {}
func (*PackageManager_Package) Descriptor() ([]byte, []int) {
	return fileDescriptorGrafeas, []int{33, 0}
}

func (m *PackageManager_Package) GetDistribution() []*PackageManager_Distribution {
	if m != nil {
		return m.Distribution
	}
	return nil
}

func (m *PackageManager_Package) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

// This represents a particular channel of distribution for a given package.
// e.g. Debian's jessie-backports dpkg mirror
type PackageManager_Distribution struct {
	Architecture PackageManager_Distribution_Architecture `protobuf:"varint,1,opt,name=architecture,proto3,enum=grafeas.v1alpha1.api.PackageManager_Distribution_Architecture" json:"architecture,omitempty"`
	// The cpe_uri in [cpe format](https://cpe.mitre.org/specification/)
	// denoting the package manager version distributing a package.
	CpeUri string `protobuf:"bytes,2,opt,name=cpe_uri,json=cpeUri,proto3" json:"cpe_uri,omitempty"`
	// The distribution channel-specific description of this package.
	Description string `protobuf:"bytes,3,opt,name=description,proto3" json:"description,omitempty"`
	// The latest available version of this package in
	// this distribution channel.
	LatestVersion *PackageManager_Version `protobuf:"bytes,4,opt,name=latest_version,json=latestVersion" json:"latest_version,omitempty"`
	// A freeform string denoting the maintainer of this package.
	Maintainer string `protobuf:"bytes,5,opt,name=maintainer,proto3" json:"maintainer,omitempty"`
	// The distribution channel-specific homepage for this package.
	Url string `protobuf:"bytes,6,opt,name=url,proto3" json:"url,omitempty"`
}

func (m *PackageManager_Distribution) Reset()         { *m = PackageManager_Distribution{} }
func (m *PackageManager_Distribution) String() string { return proto.CompactTextString(m) }
func (*PackageManager_Distribution) ProtoMessage()    {}
func (*PackageManager_Distribution) Descriptor() ([]byte, []int) {
	return fileDescriptorGrafeas, []int{33, 1}
}

func (m *PackageManager_Distribution) GetArchitecture() PackageManager_Distribution_Architecture {
	if m != nil {
		return m.Architecture
	}
	return PackageManager_Distribution_UNKNOWN
}

func (m *PackageManager_Distribution) GetCpeUri() string {
	if m != nil {
		return m.CpeUri
	}
	return ""
}

func (m *PackageManager_Distribution) GetDescription() string {
	if m != nil {
		return m.Description
	}
	return ""
}

func (m *PackageManager_Distribution) GetLatestVersion() *PackageManager_Version {
	if m != nil {
		return m.LatestVersion
	}
	return nil
}

func (m *PackageManager_Distribution) GetMaintainer() string {
	if m != nil {
		return m.Maintainer
	}
	return ""
}

func (m *PackageManager_Distribution) GetUrl() string {
	if m != nil {
		return m.Url
	}
	return ""
}

// Version contains structured information about the version of the package.
// For a discussion of this in Debian/Ubuntu:
// http://serverfault.com/questions/604541/debian-packages-version-convention
// For a discussion of this in Redhat/Fedora/Centos:
// http://blog.jasonantman.com/2014/07/how-yum-and-rpm-compare-versions/
type PackageManager_Version struct {
	// Used to correct mistakes in the version numbering scheme.
	Epoch int32 `protobuf:"varint,1,opt,name=epoch,proto3" json:"epoch,omitempty"`
	// The main part of the version name.
	Name string `protobuf:"bytes,2,opt,name=name,proto3" json:"name,omitempty"`
	// The iteration of the package build from the above version.
	Revision string `protobuf:"bytes,3,opt,name=revision,proto3" json:"revision,omitempty"`
	// Distinguish between sentinel MIN/MAX versions and normal versions.
	// If kind is not NORMAL, then the other fields are ignored.
	Kind PackageManager_Version_VersionKind `protobuf:"varint,5,opt,name=kind,proto3,enum=grafeas.v1alpha1.api.PackageManager_Version_VersionKind" json:"kind,omitempty"`
}

func (m *PackageManager_Version) Reset()         { *m = PackageManager_Version{} }
func (m *PackageManager_Version) String() string { return proto.CompactTextString(m) }
func (*PackageManager_Version) ProtoMessage()    {}
func (*PackageManager_Version) Descriptor() ([]byte, []int) {
	return fileDescriptorGrafeas, []int{33, 2}
}

func (m *PackageManager_Version) GetEpoch() int32 {
	if m != nil {
		return m.Epoch
	}
	return 0
}

func (m *PackageManager_Version) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *PackageManager_Version) GetRevision() string {
	if m != nil {
		return m.Revision
	}
	return ""
}

func (m *PackageManager_Version) GetKind() PackageManager_Version_VersionKind {
	if m != nil {
		return m.Kind
	}
	return PackageManager_Version_NORMAL
}

// An occurrence of a particular package installation found within a
// system's filesystem.
// e.g. glibc was found in /var/lib/dpkg/status
type PackageManager_Location struct {
	// The cpe_uri in [cpe format](https://cpe.mitre.org/specification/)
	// denoting the package manager version distributing a package.
	CpeUri string `protobuf:"bytes,1,opt,name=cpe_uri,json=cpeUri,proto3" json:"cpe_uri,omitempty"`
	// The path from which we gathered that this package/version is installed.
	Path string `protobuf:"bytes,2,opt,name=path,proto3" json:"path,omitempty"`
	// The version installed at this location.
	Version *VulnerabilityType_Version `protobuf:"bytes,3,opt,name=version" json:"version,omitempty"`
}

func (m *PackageManager_Location) Reset()         { *m = PackageManager_Location{} }
func (m *PackageManager_Location) String() string { return proto.CompactTextString(m) }
func (*PackageManager_Location) ProtoMessage()    {}
func (*PackageManager_Location) Descriptor() ([]byte, []int) {
	return fileDescriptorGrafeas, []int{33, 3}
}

func (m *PackageManager_Location) GetCpeUri() string {
	if m != nil {
		return m.CpeUri
	}
	return ""
}

func (m *PackageManager_Location) GetPath() string {
	if m != nil {
		return m.Path
	}
	return ""
}

func (m *PackageManager_Location) GetVersion() *VulnerabilityType_Version {
	if m != nil {
		return m.Version
	}
	return nil
}

// This represents how a particular software package may be installed on
// a system.
type PackageManager_Installation struct {
	// The name of the installed package.
	// @OutputOnly
	Name string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	// All of the places within the filesystem versions of this package
	// have been found.
	Location []*PackageManager_Location `protobuf:"bytes,2,rep,name=location" json:"location,omitempty"`
}

func (m *PackageManager_Installation) Reset()         { *m = PackageManager_Installation{} }
func (m *PackageManager_Installation) String() string { return proto.CompactTextString(m) }
func (*PackageManager_Installation) ProtoMessage()    {}
func (*PackageManager_Installation) Descriptor() ([]byte, []int) {
	return fileDescriptorGrafeas, []int{33, 4}
}

func (m *PackageManager_Installation) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *PackageManager_Installation) GetLocation() []*PackageManager_Location {
	if m != nil {
		return m.Location
	}
	return nil
}

// An attestation wrapper with a PGP-compatible signature.
// This message only supports ATTACHED signatures, where the payload that is
// signed is included alongside the signature itself in the same file.
type PgpSignedAttestation struct {
	// The raw content of the signature, as output by gpg or equivalent.  Since
	// this message only supports attached signatures, the payload that was signed
	// must be attached. While the signature format supported is dependent on the
	// verification implementation, currently only ASCII-armored (`--armor` to
	// gpg), non-clearsigned (`--sign` rather than `--clearsign` to gpg) are
	// supported.
	// Concretely, `gpg --sign --armor --output=signature.gpg payload.json` will
	// create the signature content expected in this field in `signature.gpg` for
	// the `payload.json` attestation payload.
	Signature string `protobuf:"bytes,1,opt,name=signature,proto3" json:"signature,omitempty"`
	// Type (e.g. schema) of the attestation payload that was signed.
	// The verifier must ensure that the provided type is one that the verifier
	// supports, and that the attestation payload is a valid instantiation of that
	// type (e.g. by validating a JSON schema).
	ContentType PgpSignedAttestation_ContentType `protobuf:"varint,3,opt,name=content_type,json=contentType,proto3,enum=grafeas.v1alpha1.api.PgpSignedAttestation_ContentType" json:"content_type,omitempty"`
	// This field is used by verifiers to select the public key used to validate
	// the signature.  Note that the policy of the verifier ultimately determines
	// which public keys verify a signature based on the context of the
	// verification.  There is no guarantee validation will succeed if the
	// verifier has no key matching this ID, even if it has a key under a
	// different ID that would verify the signature. Note that this ID should also
	// be present in the signature content above, but that is not expected to be
	// used by the verifier.
	//
	// Types that are valid to be assigned to KeyId:
	//	*PgpSignedAttestation_PgpKeyId
	KeyId isPgpSignedAttestation_KeyId `protobuf_oneof:"key_id"`
}

func (m *PgpSignedAttestation) Reset()                    { *m = PgpSignedAttestation{} }
func (m *PgpSignedAttestation) String() string            { return proto.CompactTextString(m) }
func (*PgpSignedAttestation) ProtoMessage()               {}
func (*PgpSignedAttestation) Descriptor() ([]byte, []int) { return fileDescriptorGrafeas, []int{34} }

type isPgpSignedAttestation_KeyId interface {
	isPgpSignedAttestation_KeyId()
	MarshalTo([]byte) (int, error)
	Size() int
}

type PgpSignedAttestation_PgpKeyId struct {
	PgpKeyId string `protobuf:"bytes,2,opt,name=pgp_key_id,json=pgpKeyId,proto3,oneof"`
}

func (*PgpSignedAttestation_PgpKeyId) isPgpSignedAttestation_KeyId() {}

func (m *PgpSignedAttestation) GetKeyId() isPgpSignedAttestation_KeyId {
	if m != nil {
		return m.KeyId
	}
	return nil
}

func (m *PgpSignedAttestation) GetSignature() string {
	if m != nil {
		return m.Signature
	}
	return ""
}

func (m *PgpSignedAttestation) GetContentType() PgpSignedAttestation_ContentType {
	if m != nil {
		return m.ContentType
	}
	return PgpSignedAttestation_CONTENT_TYPE_UNSPECIFIED
}

func (m *PgpSignedAttestation) GetPgpKeyId() string {
	if x, ok := m.GetKeyId().(*PgpSignedAttestation_PgpKeyId); ok {
		return x.PgpKeyId
	}
	return ""
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*PgpSignedAttestation) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _PgpSignedAttestation_OneofMarshaler, _PgpSignedAttestation_OneofUnmarshaler, _PgpSignedAttestation_OneofSizer, []interface{}{
		(*PgpSignedAttestation_PgpKeyId)(nil),
	}
}

func _PgpSignedAttestation_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*PgpSignedAttestation)
	// key_id
	switch x := m.KeyId.(type) {
	case *PgpSignedAttestation_PgpKeyId:
		_ = b.EncodeVarint(2<<3 | proto.WireBytes)
		_ = b.EncodeStringBytes(x.PgpKeyId)
	case nil:
	default:
		return fmt.Errorf("PgpSignedAttestation.KeyId has unexpected type %T", x)
	}
	return nil
}

func _PgpSignedAttestation_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*PgpSignedAttestation)
	switch tag {
	case 2: // key_id.pgp_key_id
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeStringBytes()
		m.KeyId = &PgpSignedAttestation_PgpKeyId{x}
		return true, err
	default:
		return false, nil
	}
}

func _PgpSignedAttestation_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*PgpSignedAttestation)
	// key_id
	switch x := m.KeyId.(type) {
	case *PgpSignedAttestation_PgpKeyId:
		n += proto.SizeVarint(2<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(len(x.PgpKeyId)))
		n += len(x.PgpKeyId)
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

// Source describes the location of the source used for the build.
type Source struct {
	// Source location information.
	//
	// Types that are valid to be assigned to Source:
	//	*Source_StorageSource
	//	*Source_RepoSource
	Source isSource_Source `protobuf_oneof:"source"`
	// If provided, the input binary artifacts for the build came from this
	// location.
	ArtifactStorageSource *StorageSource `protobuf:"bytes,4,opt,name=artifact_storage_source,json=artifactStorageSource" json:"artifact_storage_source,omitempty"`
	// If provided, the source code used for the build came from this location.
	SourceContext *google_devtools_source_v1.ExtendedSourceContext `protobuf:"bytes,5,opt,name=source_context,json=sourceContext" json:"source_context,omitempty"`
	// If provided, some of the source code used for the build may be found in
	// these locations, in the case where the source repository had multiple
	// remotes or submodules. This list will not include the context specified in
	// the source_context field.
	AdditionalSourceContexts []*google_devtools_source_v1.ExtendedSourceContext `protobuf:"bytes,6,rep,name=additional_source_contexts,json=additionalSourceContexts" json:"additional_source_contexts,omitempty"`
	// Hash(es) of the build source, which can be used to verify that the original
	// source integrity was maintained in the build.
	//
	// The keys to this map are file paths used as build source and the values
	// contain the hash values for those files.
	//
	// If the build source came in a single package such as a gzipped tarfile
	// (.tar.gz), the FileHash will be for the single path to that file.
	FileHashes map[string]*FileHashes `protobuf:"bytes,3,rep,name=file_hashes,json=fileHashes" json:"file_hashes,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value"`
}

func (m *Source) Reset()                    { *m = Source{} }
func (m *Source) String() string            { return proto.CompactTextString(m) }
func (*Source) ProtoMessage()               {}
func (*Source) Descriptor() ([]byte, []int) { return fileDescriptorGrafeas, []int{35} }

type isSource_Source interface {
	isSource_Source()
	MarshalTo([]byte) (int, error)
	Size() int
}

type Source_StorageSource struct {
	StorageSource *StorageSource `protobuf:"bytes,1,opt,name=storage_source,json=storageSource,oneof"`
}
type Source_RepoSource struct {
	RepoSource *RepoSource `protobuf:"bytes,2,opt,name=repo_source,json=repoSource,oneof"`
}

func (*Source_StorageSource) isSource_Source() {}
func (*Source_RepoSource) isSource_Source()    {}

func (m *Source) GetSource() isSource_Source {
	if m != nil {
		return m.Source
	}
	return nil
}

func (m *Source) GetStorageSource() *StorageSource {
	if x, ok := m.GetSource().(*Source_StorageSource); ok {
		return x.StorageSource
	}
	return nil
}

func (m *Source) GetRepoSource() *RepoSource {
	if x, ok := m.GetSource().(*Source_RepoSource); ok {
		return x.RepoSource
	}
	return nil
}

func (m *Source) GetArtifactStorageSource() *StorageSource {
	if m != nil {
		return m.ArtifactStorageSource
	}
	return nil
}

func (m *Source) GetSourceContext() *google_devtools_source_v1.ExtendedSourceContext {
	if m != nil {
		return m.SourceContext
	}
	return nil
}

func (m *Source) GetAdditionalSourceContexts() []*google_devtools_source_v1.ExtendedSourceContext {
	if m != nil {
		return m.AdditionalSourceContexts
	}
	return nil
}

func (m *Source) GetFileHashes() map[string]*FileHashes {
	if m != nil {
		return m.FileHashes
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*Source) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _Source_OneofMarshaler, _Source_OneofUnmarshaler, _Source_OneofSizer, []interface{}{
		(*Source_StorageSource)(nil),
		(*Source_RepoSource)(nil),
	}
}

func _Source_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*Source)
	// source
	switch x := m.Source.(type) {
	case *Source_StorageSource:
		_ = b.EncodeVarint(1<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.StorageSource); err != nil {
			return err
		}
	case *Source_RepoSource:
		_ = b.EncodeVarint(2<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.RepoSource); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("Source.Source has unexpected type %T", x)
	}
	return nil
}

func _Source_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*Source)
	switch tag {
	case 1: // source.storage_source
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(StorageSource)
		err := b.DecodeMessage(msg)
		m.Source = &Source_StorageSource{msg}
		return true, err
	case 2: // source.repo_source
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(RepoSource)
		err := b.DecodeMessage(msg)
		m.Source = &Source_RepoSource{msg}
		return true, err
	default:
		return false, nil
	}
}

func _Source_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*Source)
	// source
	switch x := m.Source.(type) {
	case *Source_StorageSource:
		s := proto.Size(x.StorageSource)
		n += proto.SizeVarint(1<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *Source_RepoSource:
		s := proto.Size(x.RepoSource)
		n += proto.SizeVarint(2<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

// RepoSource describes the location of the source in a Google Cloud Source
// Repository.
type RepoSource struct {
	// ID of the project that owns the repo.
	ProjectId string `protobuf:"bytes,1,opt,name=project_id,json=projectId,proto3" json:"project_id,omitempty"`
	// Name of the repo.
	RepoName string `protobuf:"bytes,2,opt,name=repo_name,json=repoName,proto3" json:"repo_name,omitempty"`
	// A revision within the source repository must be specified in
	// one of these ways.
	//
	// Types that are valid to be assigned to Revision:
	//	*RepoSource_BranchName
	//	*RepoSource_TagName
	//	*RepoSource_CommitSha
	Revision isRepoSource_Revision `protobuf_oneof:"revision"`
}

func (m *RepoSource) Reset()                    { *m = RepoSource{} }
func (m *RepoSource) String() string            { return proto.CompactTextString(m) }
func (*RepoSource) ProtoMessage()               {}
func (*RepoSource) Descriptor() ([]byte, []int) { return fileDescriptorGrafeas, []int{36} }

type isRepoSource_Revision interface {
	isRepoSource_Revision()
	MarshalTo([]byte) (int, error)
	Size() int
}

type RepoSource_BranchName struct {
	BranchName string `protobuf:"bytes,3,opt,name=branch_name,json=branchName,proto3,oneof"`
}
type RepoSource_TagName struct {
	TagName string `protobuf:"bytes,4,opt,name=tag_name,json=tagName,proto3,oneof"`
}
type RepoSource_CommitSha struct {
	CommitSha string `protobuf:"bytes,5,opt,name=commit_sha,json=commitSha,proto3,oneof"`
}

func (*RepoSource_BranchName) isRepoSource_Revision() {}
func (*RepoSource_TagName) isRepoSource_Revision()    {}
func (*RepoSource_CommitSha) isRepoSource_Revision()  {}

func (m *RepoSource) GetRevision() isRepoSource_Revision {
	if m != nil {
		return m.Revision
	}
	return nil
}

func (m *RepoSource) GetProjectId() string {
	if m != nil {
		return m.ProjectId
	}
	return ""
}

func (m *RepoSource) GetRepoName() string {
	if m != nil {
		return m.RepoName
	}
	return ""
}

func (m *RepoSource) GetBranchName() string {
	if x, ok := m.GetRevision().(*RepoSource_BranchName); ok {
		return x.BranchName
	}
	return ""
}

func (m *RepoSource) GetTagName() string {
	if x, ok := m.GetRevision().(*RepoSource_TagName); ok {
		return x.TagName
	}
	return ""
}

func (m *RepoSource) GetCommitSha() string {
	if x, ok := m.GetRevision().(*RepoSource_CommitSha); ok {
		return x.CommitSha
	}
	return ""
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*RepoSource) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _RepoSource_OneofMarshaler, _RepoSource_OneofUnmarshaler, _RepoSource_OneofSizer, []interface{}{
		(*RepoSource_BranchName)(nil),
		(*RepoSource_TagName)(nil),
		(*RepoSource_CommitSha)(nil),
	}
}

func _RepoSource_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*RepoSource)
	// revision
	switch x := m.Revision.(type) {
	case *RepoSource_BranchName:
		_ = b.EncodeVarint(3<<3 | proto.WireBytes)
		_ = b.EncodeStringBytes(x.BranchName)
	case *RepoSource_TagName:
		_ = b.EncodeVarint(4<<3 | proto.WireBytes)
		_ = b.EncodeStringBytes(x.TagName)
	case *RepoSource_CommitSha:
		_ = b.EncodeVarint(5<<3 | proto.WireBytes)
		_ = b.EncodeStringBytes(x.CommitSha)
	case nil:
	default:
		return fmt.Errorf("RepoSource.Revision has unexpected type %T", x)
	}
	return nil
}

func _RepoSource_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*RepoSource)
	switch tag {
	case 3: // revision.branch_name
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeStringBytes()
		m.Revision = &RepoSource_BranchName{x}
		return true, err
	case 4: // revision.tag_name
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeStringBytes()
		m.Revision = &RepoSource_TagName{x}
		return true, err
	case 5: // revision.commit_sha
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeStringBytes()
		m.Revision = &RepoSource_CommitSha{x}
		return true, err
	default:
		return false, nil
	}
}

func _RepoSource_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*RepoSource)
	// revision
	switch x := m.Revision.(type) {
	case *RepoSource_BranchName:
		n += proto.SizeVarint(3<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(len(x.BranchName)))
		n += len(x.BranchName)
	case *RepoSource_TagName:
		n += proto.SizeVarint(4<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(len(x.TagName)))
		n += len(x.TagName)
	case *RepoSource_CommitSha:
		n += proto.SizeVarint(5<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(len(x.CommitSha)))
		n += len(x.CommitSha)
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

// StorageSource describes the location of the source in an archive file in
// Google Cloud Storage.
type StorageSource struct {
	// Google Cloud Storage bucket containing source (see [Bucket Name
	// Requirements]
	// (https://cloud.google.com/storage/docs/bucket-naming#requirements)).
	Bucket string `protobuf:"bytes,1,opt,name=bucket,proto3" json:"bucket,omitempty"`
	// Google Cloud Storage generation for the object.
	Generation string `protobuf:"bytes,2,opt,name=generation,proto3" json:"generation,omitempty"`
	// Google Cloud Storage object containing source.
	Object string `protobuf:"bytes,3,opt,name=object,proto3" json:"object,omitempty"`
}

func (m *StorageSource) Reset()                    { *m = StorageSource{} }
func (m *StorageSource) String() string            { return proto.CompactTextString(m) }
func (*StorageSource) ProtoMessage()               {}
func (*StorageSource) Descriptor() ([]byte, []int) { return fileDescriptorGrafeas, []int{37} }

func (m *StorageSource) GetBucket() string {
	if m != nil {
		return m.Bucket
	}
	return ""
}

func (m *StorageSource) GetGeneration() string {
	if m != nil {
		return m.Generation
	}
	return ""
}

func (m *StorageSource) GetObject() string {
	if m != nil {
		return m.Object
	}
	return ""
}

// VulnerabilityType provides metadata about a security vulnerability.
type VulnerabilityType struct {
	// The CVSS score for this Vulnerability.
	CvssScore float32 `protobuf:"fixed32,2,opt,name=cvss_score,json=cvssScore,proto3" json:"cvss_score,omitempty"`
	// Note provider assigned impact of the vulnerability
	Severity VulnerabilityType_Severity `protobuf:"varint,3,opt,name=severity,proto3,enum=grafeas.v1alpha1.api.VulnerabilityType_Severity" json:"severity,omitempty"`
	// All information about the package to specifically identify this
	// vulnerability. One entry per (version range and cpe_uri) the
	// package vulnerability has manifested in.
	Details []*VulnerabilityType_Detail `protobuf:"bytes,4,rep,name=details" json:"details,omitempty"`
}

func (m *VulnerabilityType) Reset()                    { *m = VulnerabilityType{} }
func (m *VulnerabilityType) String() string            { return proto.CompactTextString(m) }
func (*VulnerabilityType) ProtoMessage()               {}
func (*VulnerabilityType) Descriptor() ([]byte, []int) { return fileDescriptorGrafeas, []int{38} }

func (m *VulnerabilityType) GetCvssScore() float32 {
	if m != nil {
		return m.CvssScore
	}
	return 0
}

func (m *VulnerabilityType) GetSeverity() VulnerabilityType_Severity {
	if m != nil {
		return m.Severity
	}
	return VulnerabilityType_SEVERITY_UNSPECIFIED
}

func (m *VulnerabilityType) GetDetails() []*VulnerabilityType_Detail {
	if m != nil {
		return m.Details
	}
	return nil
}

// Version contains structured information about the version of the package.
// For a discussion of this in Debian/Ubuntu:
// http://serverfault.com/questions/604541/debian-packages-version-convention
// For a discussion of this in Redhat/Fedora/Centos:
// http://blog.jasonantman.com/2014/07/how-yum-and-rpm-compare-versions/
type VulnerabilityType_Version struct {
	// Used to correct mistakes in the version numbering scheme.
	Epoch int32 `protobuf:"varint,1,opt,name=epoch,proto3" json:"epoch,omitempty"`
	// The main part of the version name.
	Name string `protobuf:"bytes,2,opt,name=name,proto3" json:"name,omitempty"`
	// The iteration of the package build from the above version.
	Revision string `protobuf:"bytes,3,opt,name=revision,proto3" json:"revision,omitempty"`
	// Distinguish between sentinel MIN/MAX versions and normal versions.
	// If kind is not NORMAL, then the other fields are ignored.
	Kind VulnerabilityType_Version_VersionKind `protobuf:"varint,5,opt,name=kind,proto3,enum=grafeas.v1alpha1.api.VulnerabilityType_Version_VersionKind" json:"kind,omitempty"`
}

func (m *VulnerabilityType_Version) Reset()         { *m = VulnerabilityType_Version{} }
func (m *VulnerabilityType_Version) String() string { return proto.CompactTextString(m) }
func (*VulnerabilityType_Version) ProtoMessage()    {}
func (*VulnerabilityType_Version) Descriptor() ([]byte, []int) {
	return fileDescriptorGrafeas, []int{38, 0}
}

func (m *VulnerabilityType_Version) GetEpoch() int32 {
	if m != nil {
		return m.Epoch
	}
	return 0
}

func (m *VulnerabilityType_Version) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *VulnerabilityType_Version) GetRevision() string {
	if m != nil {
		return m.Revision
	}
	return ""
}

func (m *VulnerabilityType_Version) GetKind() VulnerabilityType_Version_VersionKind {
	if m != nil {
		return m.Kind
	}
	return VulnerabilityType_Version_NORMAL
}

// Identifies all occurences of this vulnerability in the package for a
// specific distro/location
// For example: glibc in cpe:/o:debian:debian_linux:8 for versions 2.1 - 2.2
type VulnerabilityType_Detail struct {
	// The cpe_uri in [cpe format] (https://cpe.mitre.org/specification/) in
	// which the vulnerability manifests.  Examples include distro or storage
	// location for vulnerable jar.
	// This field can be used as a filter in list requests.
	CpeUri string `protobuf:"bytes,1,opt,name=cpe_uri,json=cpeUri,proto3" json:"cpe_uri,omitempty"`
	// The name of the package where the vulnerability was found.
	// This field can be used as a filter in list requests.
	Package string `protobuf:"bytes,8,opt,name=package,proto3" json:"package,omitempty"`
	// The min version of the package in which the vulnerability exists.
	MinAffectedVersion *VulnerabilityType_Version `protobuf:"bytes,6,opt,name=min_affected_version,json=minAffectedVersion" json:"min_affected_version,omitempty"`
	// The max version of the package in which the vulnerability exists.
	// This field can be used as a filter in list requests.
	MaxAffectedVersion *VulnerabilityType_Version `protobuf:"bytes,7,opt,name=max_affected_version,json=maxAffectedVersion" json:"max_affected_version,omitempty"`
	// The severity (eg: distro assigned severity) for this vulnerability.
	SeverityName string `protobuf:"bytes,4,opt,name=severity_name,json=severityName,proto3" json:"severity_name,omitempty"`
	// A vendor-specific description of this note.
	Description string `protobuf:"bytes,9,opt,name=description,proto3" json:"description,omitempty"`
	// The fix for this specific package version.
	FixedLocation *VulnerabilityType_VulnerabilityLocation `protobuf:"bytes,5,opt,name=fixed_location,json=fixedLocation" json:"fixed_location,omitempty"`
	// The type of package; whether native or non native(ruby gems,
	// node.js packages etc)
	PackageType string `protobuf:"bytes,10,opt,name=package_type,json=packageType,proto3" json:"package_type,omitempty"`
}

func (m *VulnerabilityType_Detail) Reset()         { *m = VulnerabilityType_Detail{} }
func (m *VulnerabilityType_Detail) String() string { return proto.CompactTextString(m) }
func (*VulnerabilityType_Detail) ProtoMessage()    {}
func (*VulnerabilityType_Detail) Descriptor() ([]byte, []int) {
	return fileDescriptorGrafeas, []int{38, 1}
}

func (m *VulnerabilityType_Detail) GetCpeUri() string {
	if m != nil {
		return m.CpeUri
	}
	return ""
}

func (m *VulnerabilityType_Detail) GetPackage() string {
	if m != nil {
		return m.Package
	}
	return ""
}

func (m *VulnerabilityType_Detail) GetMinAffectedVersion() *VulnerabilityType_Version {
	if m != nil {
		return m.MinAffectedVersion
	}
	return nil
}

func (m *VulnerabilityType_Detail) GetMaxAffectedVersion() *VulnerabilityType_Version {
	if m != nil {
		return m.MaxAffectedVersion
	}
	return nil
}

func (m *VulnerabilityType_Detail) GetSeverityName() string {
	if m != nil {
		return m.SeverityName
	}
	return ""
}

func (m *VulnerabilityType_Detail) GetDescription() string {
	if m != nil {
		return m.Description
	}
	return ""
}

func (m *VulnerabilityType_Detail) GetFixedLocation() *VulnerabilityType_VulnerabilityLocation {
	if m != nil {
		return m.FixedLocation
	}
	return nil
}

func (m *VulnerabilityType_Detail) GetPackageType() string {
	if m != nil {
		return m.PackageType
	}
	return ""
}

// Used by Occurrence to point to where the vulnerability exists and how
// to fix it.
type VulnerabilityType_VulnerabilityDetails struct {
	// The type of package; whether native or non native(ruby gems,
	// node.js packages etc)
	Type string `protobuf:"bytes,3,opt,name=type,proto3" json:"type,omitempty"`
	// The note provider assigned Severity of the vulnerability.
	// @OutputOnly
	Severity VulnerabilityType_Severity `protobuf:"varint,4,opt,name=severity,proto3,enum=grafeas.v1alpha1.api.VulnerabilityType_Severity" json:"severity,omitempty"`
	// The CVSS score of this vulnerability. CVSS score is on a scale of 0-10
	// where 0 indicates low severity and 10 indicates high severity.
	// @OutputOnly
	CvssScore float32 `protobuf:"fixed32,5,opt,name=cvss_score,json=cvssScore,proto3" json:"cvss_score,omitempty"`
	// The set of affected locations and their fixes (if available) within
	// the associated resource.
	PackageIssue []*VulnerabilityType_PackageIssue `protobuf:"bytes,6,rep,name=package_issue,json=packageIssue" json:"package_issue,omitempty"`
}

func (m *VulnerabilityType_VulnerabilityDetails) Reset() {
	*m = VulnerabilityType_VulnerabilityDetails{}
}
func (m *VulnerabilityType_VulnerabilityDetails) String() string { return proto.CompactTextString(m) }
func (*VulnerabilityType_VulnerabilityDetails) ProtoMessage()    {}
func (*VulnerabilityType_VulnerabilityDetails) Descriptor() ([]byte, []int) {
	return fileDescriptorGrafeas, []int{38, 2}
}

func (m *VulnerabilityType_VulnerabilityDetails) GetType() string {
	if m != nil {
		return m.Type
	}
	return ""
}

func (m *VulnerabilityType_VulnerabilityDetails) GetSeverity() VulnerabilityType_Severity {
	if m != nil {
		return m.Severity
	}
	return VulnerabilityType_SEVERITY_UNSPECIFIED
}

func (m *VulnerabilityType_VulnerabilityDetails) GetCvssScore() float32 {
	if m != nil {
		return m.CvssScore
	}
	return 0
}

func (m *VulnerabilityType_VulnerabilityDetails) GetPackageIssue() []*VulnerabilityType_PackageIssue {
	if m != nil {
		return m.PackageIssue
	}
	return nil
}

// This message wraps a location affected by a vulnerability and its
// associated fix (if one is available).
type VulnerabilityType_PackageIssue struct {
	// The location of the vulnerability.
	AffectedLocation *VulnerabilityType_VulnerabilityLocation `protobuf:"bytes,1,opt,name=affected_location,json=affectedLocation" json:"affected_location,omitempty"`
	// The location of the available fix for vulnerability.
	FixedLocation *VulnerabilityType_VulnerabilityLocation `protobuf:"bytes,2,opt,name=fixed_location,json=fixedLocation" json:"fixed_location,omitempty"`
	// The severity (eg: distro assigned severity) for this vulnerability.
	SeverityName string `protobuf:"bytes,3,opt,name=severity_name,json=severityName,proto3" json:"severity_name,omitempty"`
}

func (m *VulnerabilityType_PackageIssue) Reset()         { *m = VulnerabilityType_PackageIssue{} }
func (m *VulnerabilityType_PackageIssue) String() string { return proto.CompactTextString(m) }
func (*VulnerabilityType_PackageIssue) ProtoMessage()    {}
func (*VulnerabilityType_PackageIssue) Descriptor() ([]byte, []int) {
	return fileDescriptorGrafeas, []int{38, 3}
}

func (m *VulnerabilityType_PackageIssue) GetAffectedLocation() *VulnerabilityType_VulnerabilityLocation {
	if m != nil {
		return m.AffectedLocation
	}
	return nil
}

func (m *VulnerabilityType_PackageIssue) GetFixedLocation() *VulnerabilityType_VulnerabilityLocation {
	if m != nil {
		return m.FixedLocation
	}
	return nil
}

func (m *VulnerabilityType_PackageIssue) GetSeverityName() string {
	if m != nil {
		return m.SeverityName
	}
	return ""
}

// The location of the vulnerability
type VulnerabilityType_VulnerabilityLocation struct {
	// The cpe_uri in [cpe format] (https://cpe.mitre.org/specification/)
	// format. Examples include distro or storage location for vulnerable jar.
	// This field can be used as a filter in list requests.
	CpeUri string `protobuf:"bytes,1,opt,name=cpe_uri,json=cpeUri,proto3" json:"cpe_uri,omitempty"`
	// The package being described.
	Package string `protobuf:"bytes,2,opt,name=package,proto3" json:"package,omitempty"`
	// The version of the package being described.
	// This field can be used as a filter in list requests.
	Version *VulnerabilityType_Version `protobuf:"bytes,4,opt,name=version" json:"version,omitempty"`
}

func (m *VulnerabilityType_VulnerabilityLocation) Reset() {
	*m = VulnerabilityType_VulnerabilityLocation{}
}
func (m *VulnerabilityType_VulnerabilityLocation) String() string { return proto.CompactTextString(m) }
func (*VulnerabilityType_VulnerabilityLocation) ProtoMessage()    {}
func (*VulnerabilityType_VulnerabilityLocation) Descriptor() ([]byte, []int) {
	return fileDescriptorGrafeas, []int{38, 4}
}

func (m *VulnerabilityType_VulnerabilityLocation) GetCpeUri() string {
	if m != nil {
		return m.CpeUri
	}
	return ""
}

func (m *VulnerabilityType_VulnerabilityLocation) GetPackage() string {
	if m != nil {
		return m.Package
	}
	return ""
}

func (m *VulnerabilityType_VulnerabilityLocation) GetVersion() *VulnerabilityType_Version {
	if m != nil {
		return m.Version
	}
	return nil
}

func init() {
	proto.RegisterType((*GetOccurrenceRequest)(nil), "grafeas.v1alpha1.api.GetOccurrenceRequest")
	proto.RegisterType((*ListOccurrencesRequest)(nil), "grafeas.v1alpha1.api.ListOccurrencesRequest")
	proto.RegisterType((*DeleteOccurrenceRequest)(nil), "grafeas.v1alpha1.api.DeleteOccurrenceRequest")
	proto.RegisterType((*CreateOccurrenceRequest)(nil), "grafeas.v1alpha1.api.CreateOccurrenceRequest")
	proto.RegisterType((*UpdateOccurrenceRequest)(nil), "grafeas.v1alpha1.api.UpdateOccurrenceRequest")
	proto.RegisterType((*GetNoteRequest)(nil), "grafeas.v1alpha1.api.GetNoteRequest")
	proto.RegisterType((*GetOccurrenceNoteRequest)(nil), "grafeas.v1alpha1.api.GetOccurrenceNoteRequest")
	proto.RegisterType((*ListNotesRequest)(nil), "grafeas.v1alpha1.api.ListNotesRequest")
	proto.RegisterType((*DeleteNoteRequest)(nil), "grafeas.v1alpha1.api.DeleteNoteRequest")
	proto.RegisterType((*CreateNoteRequest)(nil), "grafeas.v1alpha1.api.CreateNoteRequest")
	proto.RegisterType((*UpdateNoteRequest)(nil), "grafeas.v1alpha1.api.UpdateNoteRequest")
	proto.RegisterType((*ListNoteOccurrencesRequest)(nil), "grafeas.v1alpha1.api.ListNoteOccurrencesRequest")
	proto.RegisterType((*ListNoteOccurrencesResponse)(nil), "grafeas.v1alpha1.api.ListNoteOccurrencesResponse")
	proto.RegisterType((*ListNotesResponse)(nil), "grafeas.v1alpha1.api.ListNotesResponse")
	proto.RegisterType((*ListOccurrencesResponse)(nil), "grafeas.v1alpha1.api.ListOccurrencesResponse")
	proto.RegisterType((*ListOperationsResponse)(nil), "grafeas.v1alpha1.api.ListOperationsResponse")
	proto.RegisterType((*UpdateOperationRequest)(nil), "grafeas.v1alpha1.api.UpdateOperationRequest")
	proto.RegisterType((*CreateOperationRequest)(nil), "grafeas.v1alpha1.api.CreateOperationRequest")
	proto.RegisterType((*OperationMetadata)(nil), "grafeas.v1alpha1.api.OperationMetadata")
	proto.RegisterType((*Artifact)(nil), "grafeas.v1alpha1.api.Artifact")
	proto.RegisterType((*AttestationAuthority)(nil), "grafeas.v1alpha1.api.AttestationAuthority")
	proto.RegisterType((*AttestationAuthority_AttestationAuthorityHint)(nil), "grafeas.v1alpha1.api.AttestationAuthority.AttestationAuthorityHint")
	proto.RegisterType((*AttestationAuthority_Attestation)(nil), "grafeas.v1alpha1.api.AttestationAuthority.Attestation")
	proto.RegisterType((*BuildDetails)(nil), "grafeas.v1alpha1.api.BuildDetails")
	proto.RegisterType((*BuildProvenance)(nil), "grafeas.v1alpha1.api.BuildProvenance")
	proto.RegisterType((*BuildSignature)(nil), "grafeas.v1alpha1.api.BuildSignature")
	proto.RegisterType((*BuildType)(nil), "grafeas.v1alpha1.api.BuildType")
	proto.RegisterType((*Command)(nil), "grafeas.v1alpha1.api.Command")
	proto.RegisterType((*Deployable)(nil), "grafeas.v1alpha1.api.Deployable")
	proto.RegisterType((*Deployable_Deployment)(nil), "grafeas.v1alpha1.api.Deployable.Deployment")
	proto.RegisterType((*DockerImage)(nil), "grafeas.v1alpha1.api.DockerImage")
	proto.RegisterType((*DockerImage_Layer)(nil), "grafeas.v1alpha1.api.DockerImage.Layer")
	proto.RegisterType((*DockerImage_Fingerprint)(nil), "grafeas.v1alpha1.api.DockerImage.Fingerprint")
	proto.RegisterType((*DockerImage_Basis)(nil), "grafeas.v1alpha1.api.DockerImage.Basis")
	proto.RegisterType((*DockerImage_Derived)(nil), "grafeas.v1alpha1.api.DockerImage.Derived")
	proto.RegisterType((*Discovery)(nil), "grafeas.v1alpha1.api.Discovery")
	proto.RegisterType((*Discovery_Discovered)(nil), "grafeas.v1alpha1.api.Discovery.Discovered")
	proto.RegisterType((*FileHashes)(nil), "grafeas.v1alpha1.api.FileHashes")
	proto.RegisterType((*Hash)(nil), "grafeas.v1alpha1.api.Hash")
	proto.RegisterType((*Note)(nil), "grafeas.v1alpha1.api.Note")
	proto.RegisterType((*Note_RelatedUrl)(nil), "grafeas.v1alpha1.api.Note.RelatedUrl")
	proto.RegisterType((*Occurrence)(nil), "grafeas.v1alpha1.api.Occurrence")
	proto.RegisterType((*PackageManager)(nil), "grafeas.v1alpha1.api.PackageManager")
	proto.RegisterType((*PackageManager_Package)(nil), "grafeas.v1alpha1.api.PackageManager.Package")
	proto.RegisterType((*PackageManager_Distribution)(nil), "grafeas.v1alpha1.api.PackageManager.Distribution")
	proto.RegisterType((*PackageManager_Version)(nil), "grafeas.v1alpha1.api.PackageManager.Version")
	proto.RegisterType((*PackageManager_Location)(nil), "grafeas.v1alpha1.api.PackageManager.Location")
	proto.RegisterType((*PackageManager_Installation)(nil), "grafeas.v1alpha1.api.PackageManager.Installation")
	proto.RegisterType((*PgpSignedAttestation)(nil), "grafeas.v1alpha1.api.PgpSignedAttestation")
	proto.RegisterType((*Source)(nil), "grafeas.v1alpha1.api.Source")
	proto.RegisterType((*RepoSource)(nil), "grafeas.v1alpha1.api.RepoSource")
	proto.RegisterType((*StorageSource)(nil), "grafeas.v1alpha1.api.StorageSource")
	proto.RegisterType((*VulnerabilityType)(nil), "grafeas.v1alpha1.api.VulnerabilityType")
	proto.RegisterType((*VulnerabilityType_Version)(nil), "grafeas.v1alpha1.api.VulnerabilityType.Version")
	proto.RegisterType((*VulnerabilityType_Detail)(nil), "grafeas.v1alpha1.api.VulnerabilityType.Detail")
	proto.RegisterType((*VulnerabilityType_VulnerabilityDetails)(nil), "grafeas.v1alpha1.api.VulnerabilityType.VulnerabilityDetails")
	proto.RegisterType((*VulnerabilityType_PackageIssue)(nil), "grafeas.v1alpha1.api.VulnerabilityType.PackageIssue")
	proto.RegisterType((*VulnerabilityType_VulnerabilityLocation)(nil), "grafeas.v1alpha1.api.VulnerabilityType.VulnerabilityLocation")
	proto.RegisterEnum("grafeas.v1alpha1.api.BuildSignature_KeyType", BuildSignature_KeyType_name, BuildSignature_KeyType_value)
	proto.RegisterEnum("grafeas.v1alpha1.api.DockerImage_Layer_Directive", DockerImage_Layer_Directive_name, DockerImage_Layer_Directive_value)
	proto.RegisterEnum("grafeas.v1alpha1.api.Hash_Type", Hash_Type_name, Hash_Type_value)
	proto.RegisterEnum("grafeas.v1alpha1.api.Note_Kind", Note_Kind_name, Note_Kind_value)
	proto.RegisterEnum("grafeas.v1alpha1.api.PackageManager_Distribution_Architecture", PackageManager_Distribution_Architecture_name, PackageManager_Distribution_Architecture_value)
	proto.RegisterEnum("grafeas.v1alpha1.api.PackageManager_Version_VersionKind", PackageManager_Version_VersionKind_name, PackageManager_Version_VersionKind_value)
	proto.RegisterEnum("grafeas.v1alpha1.api.PgpSignedAttestation_ContentType", PgpSignedAttestation_ContentType_name, PgpSignedAttestation_ContentType_value)
	proto.RegisterEnum("grafeas.v1alpha1.api.VulnerabilityType_Severity", VulnerabilityType_Severity_name, VulnerabilityType_Severity_value)
	proto.RegisterEnum("grafeas.v1alpha1.api.VulnerabilityType_Version_VersionKind", VulnerabilityType_Version_VersionKind_name, VulnerabilityType_Version_VersionKind_value)
}
func (m *GetOccurrenceRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetOccurrenceRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Name) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintGrafeas(dAtA, i, uint64(len(m.Name)))
		i += copy(dAtA[i:], m.Name)
	}
	return i, nil
}

func (m *ListOccurrencesRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ListOccurrencesRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Filter) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintGrafeas(dAtA, i, uint64(len(m.Filter)))
		i += copy(dAtA[i:], m.Filter)
	}
	if m.PageSize != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintGrafeas(dAtA, i, uint64(m.PageSize))
	}
	if len(m.PageToken) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintGrafeas(dAtA, i, uint64(len(m.PageToken)))
		i += copy(dAtA[i:], m.PageToken)
	}
	if len(m.Parent) > 0 {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintGrafeas(dAtA, i, uint64(len(m.Parent)))
		i += copy(dAtA[i:], m.Parent)
	}
	return i, nil
}

func (m *DeleteOccurrenceRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DeleteOccurrenceRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Name) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintGrafeas(dAtA, i, uint64(len(m.Name)))
		i += copy(dAtA[i:], m.Name)
	}
	return i, nil
}

func (m *CreateOccurrenceRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CreateOccurrenceRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Occurrence != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintGrafeas(dAtA, i, uint64(m.Occurrence.Size()))
		n1, err := m.Occurrence.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n1
	}
	if len(m.Parent) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintGrafeas(dAtA, i, uint64(len(m.Parent)))
		i += copy(dAtA[i:], m.Parent)
	}
	return i, nil
}

func (m *UpdateOccurrenceRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UpdateOccurrenceRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Name) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintGrafeas(dAtA, i, uint64(len(m.Name)))
		i += copy(dAtA[i:], m.Name)
	}
	if m.Occurrence != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintGrafeas(dAtA, i, uint64(m.Occurrence.Size()))
		n2, err := m.Occurrence.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n2
	}
	return i, nil
}

func (m *GetNoteRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetNoteRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Name) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintGrafeas(dAtA, i, uint64(len(m.Name)))
		i += copy(dAtA[i:], m.Name)
	}
	return i, nil
}

func (m *GetOccurrenceNoteRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetOccurrenceNoteRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Name) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintGrafeas(dAtA, i, uint64(len(m.Name)))
		i += copy(dAtA[i:], m.Name)
	}
	return i, nil
}

func (m *ListNotesRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ListNotesRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Name) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintGrafeas(dAtA, i, uint64(len(m.Name)))
		i += copy(dAtA[i:], m.Name)
	}
	if len(m.Filter) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintGrafeas(dAtA, i, uint64(len(m.Filter)))
		i += copy(dAtA[i:], m.Filter)
	}
	if m.PageSize != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintGrafeas(dAtA, i, uint64(m.PageSize))
	}
	if len(m.PageToken) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintGrafeas(dAtA, i, uint64(len(m.PageToken)))
		i += copy(dAtA[i:], m.PageToken)
	}
	if len(m.Parent) > 0 {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintGrafeas(dAtA, i, uint64(len(m.Parent)))
		i += copy(dAtA[i:], m.Parent)
	}
	return i, nil
}

func (m *DeleteNoteRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DeleteNoteRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Name) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintGrafeas(dAtA, i, uint64(len(m.Name)))
		i += copy(dAtA[i:], m.Name)
	}
	return i, nil
}

func (m *CreateNoteRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CreateNoteRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Name) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintGrafeas(dAtA, i, uint64(len(m.Name)))
		i += copy(dAtA[i:], m.Name)
	}
	if len(m.NoteId) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintGrafeas(dAtA, i, uint64(len(m.NoteId)))
		i += copy(dAtA[i:], m.NoteId)
	}
	if m.Note != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintGrafeas(dAtA, i, uint64(m.Note.Size()))
		n3, err := m.Note.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n3
	}
	if len(m.Parent) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintGrafeas(dAtA, i, uint64(len(m.Parent)))
		i += copy(dAtA[i:], m.Parent)
	}
	return i, nil
}

func (m *UpdateNoteRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UpdateNoteRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Name) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintGrafeas(dAtA, i, uint64(len(m.Name)))
		i += copy(dAtA[i:], m.Name)
	}
	if m.Note != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintGrafeas(dAtA, i, uint64(m.Note.Size()))
		n4, err := m.Note.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n4
	}
	return i, nil
}

func (m *ListNoteOccurrencesRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ListNoteOccurrencesRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Name) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintGrafeas(dAtA, i, uint64(len(m.Name)))
		i += copy(dAtA[i:], m.Name)
	}
	if len(m.Filter) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintGrafeas(dAtA, i, uint64(len(m.Filter)))
		i += copy(dAtA[i:], m.Filter)
	}
	if m.PageSize != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintGrafeas(dAtA, i, uint64(m.PageSize))
	}
	if len(m.PageToken) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintGrafeas(dAtA, i, uint64(len(m.PageToken)))
		i += copy(dAtA[i:], m.PageToken)
	}
	return i, nil
}

func (m *ListNoteOccurrencesResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ListNoteOccurrencesResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.NextPageToken) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintGrafeas(dAtA, i, uint64(len(m.NextPageToken)))
		i += copy(dAtA[i:], m.NextPageToken)
	}
	if len(m.Occurrences) > 0 {
		for _, msg := range m.Occurrences {
			dAtA[i] = 0x12
			i++
			i = encodeVarintGrafeas(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *ListNotesResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ListNotesResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.NextPageToken) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintGrafeas(dAtA, i, uint64(len(m.NextPageToken)))
		i += copy(dAtA[i:], m.NextPageToken)
	}
	if len(m.Notes) > 0 {
		for _, msg := range m.Notes {
			dAtA[i] = 0x12
			i++
			i = encodeVarintGrafeas(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *ListOccurrencesResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ListOccurrencesResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.NextPageToken) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintGrafeas(dAtA, i, uint64(len(m.NextPageToken)))
		i += copy(dAtA[i:], m.NextPageToken)
	}
	if len(m.Occurrences) > 0 {
		for _, msg := range m.Occurrences {
			dAtA[i] = 0x12
			i++
			i = encodeVarintGrafeas(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *ListOperationsResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ListOperationsResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.NextPageToken) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintGrafeas(dAtA, i, uint64(len(m.NextPageToken)))
		i += copy(dAtA[i:], m.NextPageToken)
	}
	if len(m.Operations) > 0 {
		for _, msg := range m.Operations {
			dAtA[i] = 0x12
			i++
			i = encodeVarintGrafeas(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *UpdateOperationRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UpdateOperationRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Name) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintGrafeas(dAtA, i, uint64(len(m.Name)))
		i += copy(dAtA[i:], m.Name)
	}
	if m.Operation != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintGrafeas(dAtA, i, uint64(m.Operation.Size()))
		n5, err := m.Operation.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n5
	}
	return i, nil
}

func (m *CreateOperationRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CreateOperationRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Parent) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintGrafeas(dAtA, i, uint64(len(m.Parent)))
		i += copy(dAtA[i:], m.Parent)
	}
	if len(m.OperationId) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintGrafeas(dAtA, i, uint64(len(m.OperationId)))
		i += copy(dAtA[i:], m.OperationId)
	}
	if m.Operation != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintGrafeas(dAtA, i, uint64(m.Operation.Size()))
		n6, err := m.Operation.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n6
	}
	return i, nil
}

func (m *OperationMetadata) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *OperationMetadata) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.CreateTime != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintGrafeas(dAtA, i, uint64(m.CreateTime.Size()))
		n7, err := m.CreateTime.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n7
	}
	if m.EndTime != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintGrafeas(dAtA, i, uint64(m.EndTime.Size()))
		n8, err := m.EndTime.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n8
	}
	return i, nil
}

func (m *Artifact) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Artifact) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Checksum) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintGrafeas(dAtA, i, uint64(len(m.Checksum)))
		i += copy(dAtA[i:], m.Checksum)
	}
	if len(m.Id) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintGrafeas(dAtA, i, uint64(len(m.Id)))
		i += copy(dAtA[i:], m.Id)
	}
	if len(m.Names) > 0 {
		for _, s := range m.Names {
			dAtA[i] = 0x1a
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	return i, nil
}

func (m *AttestationAuthority) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AttestationAuthority) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Hint != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintGrafeas(dAtA, i, uint64(m.Hint.Size()))
		n9, err := m.Hint.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n9
	}
	return i, nil
}

func (m *AttestationAuthority_AttestationAuthorityHint) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AttestationAuthority_AttestationAuthorityHint) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.HumanReadableName) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintGrafeas(dAtA, i, uint64(len(m.HumanReadableName)))
		i += copy(dAtA[i:], m.HumanReadableName)
	}
	return i, nil
}

func (m *AttestationAuthority_Attestation) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AttestationAuthority_Attestation) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Signature != nil {
		nn10, err := m.Signature.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += nn10
	}
	return i, nil
}

func (m *AttestationAuthority_Attestation_PgpSignedAttestation) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.PgpSignedAttestation != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintGrafeas(dAtA, i, uint64(m.PgpSignedAttestation.Size()))
		n11, err := m.PgpSignedAttestation.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n11
	}
	return i, nil
}
func (m *BuildDetails) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BuildDetails) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Provenance != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintGrafeas(dAtA, i, uint64(m.Provenance.Size()))
		n12, err := m.Provenance.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n12
	}
	if len(m.ProvenanceBytes) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintGrafeas(dAtA, i, uint64(len(m.ProvenanceBytes)))
		i += copy(dAtA[i:], m.ProvenanceBytes)
	}
	return i, nil
}

func (m *BuildProvenance) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BuildProvenance) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.BuildOptions) > 0 {
		for k, _ := range m.BuildOptions {
			dAtA[i] = 0xa
			i++
			v := m.BuildOptions[k]
			mapSize := 1 + len(k) + sovGrafeas(uint64(len(k))) + 1 + len(v) + sovGrafeas(uint64(len(v)))
			i = encodeVarintGrafeas(dAtA, i, uint64(mapSize))
			dAtA[i] = 0xa
			i++
			i = encodeVarintGrafeas(dAtA, i, uint64(len(k)))
			i += copy(dAtA[i:], k)
			dAtA[i] = 0x12
			i++
			i = encodeVarintGrafeas(dAtA, i, uint64(len(v)))
			i += copy(dAtA[i:], v)
		}
	}
	if len(m.BuilderVersion) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintGrafeas(dAtA, i, uint64(len(m.BuilderVersion)))
		i += copy(dAtA[i:], m.BuilderVersion)
	}
	if len(m.BuiltArtifacts) > 0 {
		for _, msg := range m.BuiltArtifacts {
			dAtA[i] = 0x1a
			i++
			i = encodeVarintGrafeas(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.Commands) > 0 {
		for _, msg := range m.Commands {
			dAtA[i] = 0x22
			i++
			i = encodeVarintGrafeas(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.CreateTime) > 0 {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintGrafeas(dAtA, i, uint64(len(m.CreateTime)))
		i += copy(dAtA[i:], m.CreateTime)
	}
	if len(m.Creator) > 0 {
		dAtA[i] = 0x32
		i++
		i = encodeVarintGrafeas(dAtA, i, uint64(len(m.Creator)))
		i += copy(dAtA[i:], m.Creator)
	}
	if len(m.FinishTime) > 0 {
		dAtA[i] = 0x3a
		i++
		i = encodeVarintGrafeas(dAtA, i, uint64(len(m.FinishTime)))
		i += copy(dAtA[i:], m.FinishTime)
	}
	if len(m.Id) > 0 {
		dAtA[i] = 0x42
		i++
		i = encodeVarintGrafeas(dAtA, i, uint64(len(m.Id)))
		i += copy(dAtA[i:], m.Id)
	}
	if len(m.LogsBucket) > 0 {
		dAtA[i] = 0x4a
		i++
		i = encodeVarintGrafeas(dAtA, i, uint64(len(m.LogsBucket)))
		i += copy(dAtA[i:], m.LogsBucket)
	}
	if len(m.ProjectId) > 0 {
		dAtA[i] = 0x52
		i++
		i = encodeVarintGrafeas(dAtA, i, uint64(len(m.ProjectId)))
		i += copy(dAtA[i:], m.ProjectId)
	}
	if len(m.ProjectNum) > 0 {
		dAtA[i] = 0x5a
		i++
		i = encodeVarintGrafeas(dAtA, i, uint64(len(m.ProjectNum)))
		i += copy(dAtA[i:], m.ProjectNum)
	}
	if m.SourceProvenance != nil {
		dAtA[i] = 0x62
		i++
		i = encodeVarintGrafeas(dAtA, i, uint64(m.SourceProvenance.Size()))
		n13, err := m.SourceProvenance.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n13
	}
	if len(m.StartTime) > 0 {
		dAtA[i] = 0x6a
		i++
		i = encodeVarintGrafeas(dAtA, i, uint64(len(m.StartTime)))
		i += copy(dAtA[i:], m.StartTime)
	}
	if len(m.TriggerId) > 0 {
		dAtA[i] = 0x72
		i++
		i = encodeVarintGrafeas(dAtA, i, uint64(len(m.TriggerId)))
		i += copy(dAtA[i:], m.TriggerId)
	}
	return i, nil
}

func (m *BuildSignature) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BuildSignature) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.KeyId) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintGrafeas(dAtA, i, uint64(len(m.KeyId)))
		i += copy(dAtA[i:], m.KeyId)
	}
	if m.KeyType != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintGrafeas(dAtA, i, uint64(m.KeyType))
	}
	if len(m.PublicKey) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintGrafeas(dAtA, i, uint64(len(m.PublicKey)))
		i += copy(dAtA[i:], m.PublicKey)
	}
	if len(m.Signature) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintGrafeas(dAtA, i, uint64(len(m.Signature)))
		i += copy(dAtA[i:], m.Signature)
	}
	return i, nil
}

func (m *BuildType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BuildType) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.BuilderVersion) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintGrafeas(dAtA, i, uint64(len(m.BuilderVersion)))
		i += copy(dAtA[i:], m.BuilderVersion)
	}
	if m.Signature != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintGrafeas(dAtA, i, uint64(m.Signature.Size()))
		n14, err := m.Signature.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n14
	}
	return i, nil
}

func (m *Command) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Command) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Args) > 0 {
		for _, s := range m.Args {
			dAtA[i] = 0xa
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if len(m.Dir) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintGrafeas(dAtA, i, uint64(len(m.Dir)))
		i += copy(dAtA[i:], m.Dir)
	}
	if len(m.Env) > 0 {
		for _, s := range m.Env {
			dAtA[i] = 0x1a
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if len(m.Id) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintGrafeas(dAtA, i, uint64(len(m.Id)))
		i += copy(dAtA[i:], m.Id)
	}
	if len(m.Name) > 0 {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintGrafeas(dAtA, i, uint64(len(m.Name)))
		i += copy(dAtA[i:], m.Name)
	}
	if len(m.WaitFor) > 0 {
		for _, s := range m.WaitFor {
			dAtA[i] = 0x32
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	return i, nil
}

func (m *Deployable) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Deployable) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.ResourceUri) > 0 {
		for _, s := range m.ResourceUri {
			dAtA[i] = 0xa
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	return i, nil
}

func (m *Deployable_Deployment) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Deployable_Deployment) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Address) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintGrafeas(dAtA, i, uint64(len(m.Address)))
		i += copy(dAtA[i:], m.Address)
	}
	if len(m.Config) > 0 {
		for k, _ := range m.Config {
			dAtA[i] = 0x12
			i++
			v := m.Config[k]
			mapSize := 1 + len(k) + sovGrafeas(uint64(len(k))) + 1 + len(v) + sovGrafeas(uint64(len(v)))
			i = encodeVarintGrafeas(dAtA, i, uint64(mapSize))
			dAtA[i] = 0xa
			i++
			i = encodeVarintGrafeas(dAtA, i, uint64(len(k)))
			i += copy(dAtA[i:], k)
			dAtA[i] = 0x12
			i++
			i = encodeVarintGrafeas(dAtA, i, uint64(len(v)))
			i += copy(dAtA[i:], v)
		}
	}
	if len(m.DeployTime) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintGrafeas(dAtA, i, uint64(len(m.DeployTime)))
		i += copy(dAtA[i:], m.DeployTime)
	}
	if len(m.UndeployTime) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintGrafeas(dAtA, i, uint64(len(m.UndeployTime)))
		i += copy(dAtA[i:], m.UndeployTime)
	}
	if len(m.UserEmail) > 0 {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintGrafeas(dAtA, i, uint64(len(m.UserEmail)))
		i += copy(dAtA[i:], m.UserEmail)
	}
	return i, nil
}

func (m *DockerImage) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DockerImage) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	return i, nil
}

func (m *DockerImage_Layer) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DockerImage_Layer) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Arguments) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintGrafeas(dAtA, i, uint64(len(m.Arguments)))
		i += copy(dAtA[i:], m.Arguments)
	}
	if m.Directive != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintGrafeas(dAtA, i, uint64(m.Directive))
	}
	return i, nil
}

func (m *DockerImage_Fingerprint) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DockerImage_Fingerprint) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.V1Name) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintGrafeas(dAtA, i, uint64(len(m.V1Name)))
		i += copy(dAtA[i:], m.V1Name)
	}
	if len(m.V2Blob) > 0 {
		for _, s := range m.V2Blob {
			dAtA[i] = 0x12
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if len(m.V2Name) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintGrafeas(dAtA, i, uint64(len(m.V2Name)))
		i += copy(dAtA[i:], m.V2Name)
	}
	return i, nil
}

func (m *DockerImage_Basis) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DockerImage_Basis) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Fingerprint != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintGrafeas(dAtA, i, uint64(m.Fingerprint.Size()))
		n15, err := m.Fingerprint.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n15
	}
	if len(m.ResourceUrl) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintGrafeas(dAtA, i, uint64(len(m.ResourceUrl)))
		i += copy(dAtA[i:], m.ResourceUrl)
	}
	return i, nil
}

func (m *DockerImage_Derived) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DockerImage_Derived) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.BaseResourceUrl) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintGrafeas(dAtA, i, uint64(len(m.BaseResourceUrl)))
		i += copy(dAtA[i:], m.BaseResourceUrl)
	}
	if m.Distance != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintGrafeas(dAtA, i, uint64(m.Distance))
	}
	if m.Fingerprint != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintGrafeas(dAtA, i, uint64(m.Fingerprint.Size()))
		n16, err := m.Fingerprint.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n16
	}
	if len(m.LayerInfo) > 0 {
		for _, msg := range m.LayerInfo {
			dAtA[i] = 0x22
			i++
			i = encodeVarintGrafeas(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *Discovery) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Discovery) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.AnalysisKind != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintGrafeas(dAtA, i, uint64(m.AnalysisKind))
	}
	return i, nil
}

func (m *Discovery_Discovered) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Discovery_Discovered) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Operation != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintGrafeas(dAtA, i, uint64(m.Operation.Size()))
		n17, err := m.Operation.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n17
	}
	return i, nil
}

func (m *FileHashes) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FileHashes) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.FileHash) > 0 {
		for _, msg := range m.FileHash {
			dAtA[i] = 0xa
			i++
			i = encodeVarintGrafeas(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *Hash) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Hash) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Type != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintGrafeas(dAtA, i, uint64(m.Type))
	}
	if len(m.Value) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintGrafeas(dAtA, i, uint64(len(m.Value)))
		i += copy(dAtA[i:], m.Value)
	}
	return i, nil
}

func (m *Note) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Note) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Name) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintGrafeas(dAtA, i, uint64(len(m.Name)))
		i += copy(dAtA[i:], m.Name)
	}
	if len(m.ShortDescription) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintGrafeas(dAtA, i, uint64(len(m.ShortDescription)))
		i += copy(dAtA[i:], m.ShortDescription)
	}
	if len(m.LongDescription) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintGrafeas(dAtA, i, uint64(len(m.LongDescription)))
		i += copy(dAtA[i:], m.LongDescription)
	}
	if m.NoteType != nil {
		nn18, err := m.NoteType.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += nn18
	}
	if len(m.RelatedUrl) > 0 {
		for _, msg := range m.RelatedUrl {
			dAtA[i] = 0x3a
			i++
			i = encodeVarintGrafeas(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.Kind != 0 {
		dAtA[i] = 0x48
		i++
		i = encodeVarintGrafeas(dAtA, i, uint64(m.Kind))
	}
	if m.ExpirationTime != nil {
		dAtA[i] = 0x52
		i++
		i = encodeVarintGrafeas(dAtA, i, uint64(m.ExpirationTime.Size()))
		n19, err := m.ExpirationTime.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n19
	}
	if m.CreateTime != nil {
		dAtA[i] = 0x5a
		i++
		i = encodeVarintGrafeas(dAtA, i, uint64(m.CreateTime.Size()))
		n20, err := m.CreateTime.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n20
	}
	if m.UpdateTime != nil {
		dAtA[i] = 0x62
		i++
		i = encodeVarintGrafeas(dAtA, i, uint64(m.UpdateTime.Size()))
		n21, err := m.UpdateTime.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n21
	}
	if len(m.OperationName) > 0 {
		dAtA[i] = 0x7a
		i++
		i = encodeVarintGrafeas(dAtA, i, uint64(len(m.OperationName)))
		i += copy(dAtA[i:], m.OperationName)
	}
	return i, nil
}

func (m *Note_VulnerabilityType) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.VulnerabilityType != nil {
		dAtA[i] = 0x32
		i++
		i = encodeVarintGrafeas(dAtA, i, uint64(m.VulnerabilityType.Size()))
		n22, err := m.VulnerabilityType.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n22
	}
	return i, nil
}
func (m *Note_BuildType) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.BuildType != nil {
		dAtA[i] = 0x42
		i++
		i = encodeVarintGrafeas(dAtA, i, uint64(m.BuildType.Size()))
		n23, err := m.BuildType.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n23
	}
	return i, nil
}
func (m *Note_BaseImage) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.BaseImage != nil {
		dAtA[i] = 0x6a
		i++
		i = encodeVarintGrafeas(dAtA, i, uint64(m.BaseImage.Size()))
		n24, err := m.BaseImage.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n24
	}
	return i, nil
}
func (m *Note_Package) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.Package != nil {
		dAtA[i] = 0x72
		i++
		i = encodeVarintGrafeas(dAtA, i, uint64(m.Package.Size()))
		n25, err := m.Package.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n25
	}
	return i, nil
}
func (m *Note_Deployable) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.Deployable != nil {
		dAtA[i] = 0x8a
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintGrafeas(dAtA, i, uint64(m.Deployable.Size()))
		n26, err := m.Deployable.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n26
	}
	return i, nil
}
func (m *Note_Discovery) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.Discovery != nil {
		dAtA[i] = 0x92
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintGrafeas(dAtA, i, uint64(m.Discovery.Size()))
		n27, err := m.Discovery.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n27
	}
	return i, nil
}
func (m *Note_AttestationAuthority) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.AttestationAuthority != nil {
		dAtA[i] = 0x9a
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintGrafeas(dAtA, i, uint64(m.AttestationAuthority.Size()))
		n28, err := m.AttestationAuthority.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n28
	}
	return i, nil
}
func (m *Note_RelatedUrl) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Note_RelatedUrl) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Url) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintGrafeas(dAtA, i, uint64(len(m.Url)))
		i += copy(dAtA[i:], m.Url)
	}
	if len(m.Label) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintGrafeas(dAtA, i, uint64(len(m.Label)))
		i += copy(dAtA[i:], m.Label)
	}
	return i, nil
}

func (m *Occurrence) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Occurrence) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Name) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintGrafeas(dAtA, i, uint64(len(m.Name)))
		i += copy(dAtA[i:], m.Name)
	}
	if len(m.ResourceUrl) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintGrafeas(dAtA, i, uint64(len(m.ResourceUrl)))
		i += copy(dAtA[i:], m.ResourceUrl)
	}
	if len(m.NoteName) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintGrafeas(dAtA, i, uint64(len(m.NoteName)))
		i += copy(dAtA[i:], m.NoteName)
	}
	if len(m.Remediation) > 0 {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintGrafeas(dAtA, i, uint64(len(m.Remediation)))
		i += copy(dAtA[i:], m.Remediation)
	}
	if m.Kind != 0 {
		dAtA[i] = 0x30
		i++
		i = encodeVarintGrafeas(dAtA, i, uint64(m.Kind))
	}
	if m.Details != nil {
		nn29, err := m.Details.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += nn29
	}
	if m.CreateTime != nil {
		dAtA[i] = 0x4a
		i++
		i = encodeVarintGrafeas(dAtA, i, uint64(m.CreateTime.Size()))
		n30, err := m.CreateTime.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n30
	}
	if m.UpdateTime != nil {
		dAtA[i] = 0x52
		i++
		i = encodeVarintGrafeas(dAtA, i, uint64(m.UpdateTime.Size()))
		n31, err := m.UpdateTime.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n31
	}
	if len(m.OperationName) > 0 {
		dAtA[i] = 0x6a
		i++
		i = encodeVarintGrafeas(dAtA, i, uint64(len(m.OperationName)))
		i += copy(dAtA[i:], m.OperationName)
	}
	return i, nil
}

func (m *Occurrence_BuildDetails) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.BuildDetails != nil {
		dAtA[i] = 0x3a
		i++
		i = encodeVarintGrafeas(dAtA, i, uint64(m.BuildDetails.Size()))
		n32, err := m.BuildDetails.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n32
	}
	return i, nil
}
func (m *Occurrence_VulnerabilityDetails) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.VulnerabilityDetails != nil {
		dAtA[i] = 0x42
		i++
		i = encodeVarintGrafeas(dAtA, i, uint64(m.VulnerabilityDetails.Size()))
		n33, err := m.VulnerabilityDetails.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n33
	}
	return i, nil
}
func (m *Occurrence_DerivedImage) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.DerivedImage != nil {
		dAtA[i] = 0x5a
		i++
		i = encodeVarintGrafeas(dAtA, i, uint64(m.DerivedImage.Size()))
		n34, err := m.DerivedImage.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n34
	}
	return i, nil
}
func (m *Occurrence_Installation) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.Installation != nil {
		dAtA[i] = 0x62
		i++
		i = encodeVarintGrafeas(dAtA, i, uint64(m.Installation.Size()))
		n35, err := m.Installation.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n35
	}
	return i, nil
}
func (m *Occurrence_Deployment) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.Deployment != nil {
		dAtA[i] = 0x72
		i++
		i = encodeVarintGrafeas(dAtA, i, uint64(m.Deployment.Size()))
		n36, err := m.Deployment.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n36
	}
	return i, nil
}
func (m *Occurrence_Discovered) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.Discovered != nil {
		dAtA[i] = 0x7a
		i++
		i = encodeVarintGrafeas(dAtA, i, uint64(m.Discovered.Size()))
		n37, err := m.Discovered.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n37
	}
	return i, nil
}
func (m *Occurrence_Attestation) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.Attestation != nil {
		dAtA[i] = 0x82
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintGrafeas(dAtA, i, uint64(m.Attestation.Size()))
		n38, err := m.Attestation.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n38
	}
	return i, nil
}
func (m *PackageManager) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PackageManager) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	return i, nil
}

func (m *PackageManager_Package) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PackageManager_Package) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Distribution) > 0 {
		for _, msg := range m.Distribution {
			dAtA[i] = 0xa
			i++
			i = encodeVarintGrafeas(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.Name) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintGrafeas(dAtA, i, uint64(len(m.Name)))
		i += copy(dAtA[i:], m.Name)
	}
	return i, nil
}

func (m *PackageManager_Distribution) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PackageManager_Distribution) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Architecture != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintGrafeas(dAtA, i, uint64(m.Architecture))
	}
	if len(m.CpeUri) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintGrafeas(dAtA, i, uint64(len(m.CpeUri)))
		i += copy(dAtA[i:], m.CpeUri)
	}
	if len(m.Description) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintGrafeas(dAtA, i, uint64(len(m.Description)))
		i += copy(dAtA[i:], m.Description)
	}
	if m.LatestVersion != nil {
		dAtA[i] = 0x22
		i++
		i = encodeVarintGrafeas(dAtA, i, uint64(m.LatestVersion.Size()))
		n39, err := m.LatestVersion.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n39
	}
	if len(m.Maintainer) > 0 {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintGrafeas(dAtA, i, uint64(len(m.Maintainer)))
		i += copy(dAtA[i:], m.Maintainer)
	}
	if len(m.Url) > 0 {
		dAtA[i] = 0x32
		i++
		i = encodeVarintGrafeas(dAtA, i, uint64(len(m.Url)))
		i += copy(dAtA[i:], m.Url)
	}
	return i, nil
}

func (m *PackageManager_Version) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PackageManager_Version) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Epoch != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintGrafeas(dAtA, i, uint64(m.Epoch))
	}
	if len(m.Name) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintGrafeas(dAtA, i, uint64(len(m.Name)))
		i += copy(dAtA[i:], m.Name)
	}
	if len(m.Revision) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintGrafeas(dAtA, i, uint64(len(m.Revision)))
		i += copy(dAtA[i:], m.Revision)
	}
	if m.Kind != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintGrafeas(dAtA, i, uint64(m.Kind))
	}
	return i, nil
}

func (m *PackageManager_Location) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PackageManager_Location) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.CpeUri) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintGrafeas(dAtA, i, uint64(len(m.CpeUri)))
		i += copy(dAtA[i:], m.CpeUri)
	}
	if len(m.Path) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintGrafeas(dAtA, i, uint64(len(m.Path)))
		i += copy(dAtA[i:], m.Path)
	}
	if m.Version != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintGrafeas(dAtA, i, uint64(m.Version.Size()))
		n40, err := m.Version.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n40
	}
	return i, nil
}

func (m *PackageManager_Installation) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PackageManager_Installation) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Name) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintGrafeas(dAtA, i, uint64(len(m.Name)))
		i += copy(dAtA[i:], m.Name)
	}
	if len(m.Location) > 0 {
		for _, msg := range m.Location {
			dAtA[i] = 0x12
			i++
			i = encodeVarintGrafeas(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *PgpSignedAttestation) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PgpSignedAttestation) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Signature) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintGrafeas(dAtA, i, uint64(len(m.Signature)))
		i += copy(dAtA[i:], m.Signature)
	}
	if m.KeyId != nil {
		nn41, err := m.KeyId.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += nn41
	}
	if m.ContentType != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintGrafeas(dAtA, i, uint64(m.ContentType))
	}
	return i, nil
}

func (m *PgpSignedAttestation_PgpKeyId) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	dAtA[i] = 0x12
	i++
	i = encodeVarintGrafeas(dAtA, i, uint64(len(m.PgpKeyId)))
	i += copy(dAtA[i:], m.PgpKeyId)
	return i, nil
}
func (m *Source) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Source) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Source != nil {
		nn42, err := m.Source.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += nn42
	}
	if len(m.FileHashes) > 0 {
		for k, _ := range m.FileHashes {
			dAtA[i] = 0x1a
			i++
			v := m.FileHashes[k]
			msgSize := 0
			if v != nil {
				msgSize = v.Size()
				msgSize += 1 + sovGrafeas(uint64(msgSize))
			}
			mapSize := 1 + len(k) + sovGrafeas(uint64(len(k))) + msgSize
			i = encodeVarintGrafeas(dAtA, i, uint64(mapSize))
			dAtA[i] = 0xa
			i++
			i = encodeVarintGrafeas(dAtA, i, uint64(len(k)))
			i += copy(dAtA[i:], k)
			if v != nil {
				dAtA[i] = 0x12
				i++
				i = encodeVarintGrafeas(dAtA, i, uint64(v.Size()))
				n43, err := v.MarshalTo(dAtA[i:])
				if err != nil {
					return 0, err
				}
				i += n43
			}
		}
	}
	if m.ArtifactStorageSource != nil {
		dAtA[i] = 0x22
		i++
		i = encodeVarintGrafeas(dAtA, i, uint64(m.ArtifactStorageSource.Size()))
		n44, err := m.ArtifactStorageSource.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n44
	}
	if m.SourceContext != nil {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintGrafeas(dAtA, i, uint64(m.SourceContext.Size()))
		n45, err := m.SourceContext.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n45
	}
	if len(m.AdditionalSourceContexts) > 0 {
		for _, msg := range m.AdditionalSourceContexts {
			dAtA[i] = 0x32
			i++
			i = encodeVarintGrafeas(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *Source_StorageSource) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.StorageSource != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintGrafeas(dAtA, i, uint64(m.StorageSource.Size()))
		n46, err := m.StorageSource.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n46
	}
	return i, nil
}
func (m *Source_RepoSource) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.RepoSource != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintGrafeas(dAtA, i, uint64(m.RepoSource.Size()))
		n47, err := m.RepoSource.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n47
	}
	return i, nil
}
func (m *RepoSource) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RepoSource) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.ProjectId) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintGrafeas(dAtA, i, uint64(len(m.ProjectId)))
		i += copy(dAtA[i:], m.ProjectId)
	}
	if len(m.RepoName) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintGrafeas(dAtA, i, uint64(len(m.RepoName)))
		i += copy(dAtA[i:], m.RepoName)
	}
	if m.Revision != nil {
		nn48, err := m.Revision.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += nn48
	}
	return i, nil
}

func (m *RepoSource_BranchName) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	dAtA[i] = 0x1a
	i++
	i = encodeVarintGrafeas(dAtA, i, uint64(len(m.BranchName)))
	i += copy(dAtA[i:], m.BranchName)
	return i, nil
}
func (m *RepoSource_TagName) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	dAtA[i] = 0x22
	i++
	i = encodeVarintGrafeas(dAtA, i, uint64(len(m.TagName)))
	i += copy(dAtA[i:], m.TagName)
	return i, nil
}
func (m *RepoSource_CommitSha) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	dAtA[i] = 0x2a
	i++
	i = encodeVarintGrafeas(dAtA, i, uint64(len(m.CommitSha)))
	i += copy(dAtA[i:], m.CommitSha)
	return i, nil
}
func (m *StorageSource) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *StorageSource) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Bucket) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintGrafeas(dAtA, i, uint64(len(m.Bucket)))
		i += copy(dAtA[i:], m.Bucket)
	}
	if len(m.Generation) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintGrafeas(dAtA, i, uint64(len(m.Generation)))
		i += copy(dAtA[i:], m.Generation)
	}
	if len(m.Object) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintGrafeas(dAtA, i, uint64(len(m.Object)))
		i += copy(dAtA[i:], m.Object)
	}
	return i, nil
}

func (m *VulnerabilityType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *VulnerabilityType) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.CvssScore != 0 {
		dAtA[i] = 0x15
		i++
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.CvssScore))))
		i += 4
	}
	if m.Severity != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintGrafeas(dAtA, i, uint64(m.Severity))
	}
	if len(m.Details) > 0 {
		for _, msg := range m.Details {
			dAtA[i] = 0x22
			i++
			i = encodeVarintGrafeas(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *VulnerabilityType_Version) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *VulnerabilityType_Version) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Epoch != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintGrafeas(dAtA, i, uint64(m.Epoch))
	}
	if len(m.Name) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintGrafeas(dAtA, i, uint64(len(m.Name)))
		i += copy(dAtA[i:], m.Name)
	}
	if len(m.Revision) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintGrafeas(dAtA, i, uint64(len(m.Revision)))
		i += copy(dAtA[i:], m.Revision)
	}
	if m.Kind != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintGrafeas(dAtA, i, uint64(m.Kind))
	}
	return i, nil
}

func (m *VulnerabilityType_Detail) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *VulnerabilityType_Detail) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.CpeUri) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintGrafeas(dAtA, i, uint64(len(m.CpeUri)))
		i += copy(dAtA[i:], m.CpeUri)
	}
	if len(m.SeverityName) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintGrafeas(dAtA, i, uint64(len(m.SeverityName)))
		i += copy(dAtA[i:], m.SeverityName)
	}
	if m.FixedLocation != nil {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintGrafeas(dAtA, i, uint64(m.FixedLocation.Size()))
		n49, err := m.FixedLocation.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n49
	}
	if m.MinAffectedVersion != nil {
		dAtA[i] = 0x32
		i++
		i = encodeVarintGrafeas(dAtA, i, uint64(m.MinAffectedVersion.Size()))
		n50, err := m.MinAffectedVersion.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n50
	}
	if m.MaxAffectedVersion != nil {
		dAtA[i] = 0x3a
		i++
		i = encodeVarintGrafeas(dAtA, i, uint64(m.MaxAffectedVersion.Size()))
		n51, err := m.MaxAffectedVersion.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n51
	}
	if len(m.Package) > 0 {
		dAtA[i] = 0x42
		i++
		i = encodeVarintGrafeas(dAtA, i, uint64(len(m.Package)))
		i += copy(dAtA[i:], m.Package)
	}
	if len(m.Description) > 0 {
		dAtA[i] = 0x4a
		i++
		i = encodeVarintGrafeas(dAtA, i, uint64(len(m.Description)))
		i += copy(dAtA[i:], m.Description)
	}
	if len(m.PackageType) > 0 {
		dAtA[i] = 0x52
		i++
		i = encodeVarintGrafeas(dAtA, i, uint64(len(m.PackageType)))
		i += copy(dAtA[i:], m.PackageType)
	}
	return i, nil
}

func (m *VulnerabilityType_VulnerabilityDetails) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *VulnerabilityType_VulnerabilityDetails) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Type) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintGrafeas(dAtA, i, uint64(len(m.Type)))
		i += copy(dAtA[i:], m.Type)
	}
	if m.Severity != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintGrafeas(dAtA, i, uint64(m.Severity))
	}
	if m.CvssScore != 0 {
		dAtA[i] = 0x2d
		i++
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.CvssScore))))
		i += 4
	}
	if len(m.PackageIssue) > 0 {
		for _, msg := range m.PackageIssue {
			dAtA[i] = 0x32
			i++
			i = encodeVarintGrafeas(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *VulnerabilityType_PackageIssue) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *VulnerabilityType_PackageIssue) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.AffectedLocation != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintGrafeas(dAtA, i, uint64(m.AffectedLocation.Size()))
		n52, err := m.AffectedLocation.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n52
	}
	if m.FixedLocation != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintGrafeas(dAtA, i, uint64(m.FixedLocation.Size()))
		n53, err := m.FixedLocation.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n53
	}
	if len(m.SeverityName) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintGrafeas(dAtA, i, uint64(len(m.SeverityName)))
		i += copy(dAtA[i:], m.SeverityName)
	}
	return i, nil
}

func (m *VulnerabilityType_VulnerabilityLocation) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *VulnerabilityType_VulnerabilityLocation) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.CpeUri) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintGrafeas(dAtA, i, uint64(len(m.CpeUri)))
		i += copy(dAtA[i:], m.CpeUri)
	}
	if len(m.Package) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintGrafeas(dAtA, i, uint64(len(m.Package)))
		i += copy(dAtA[i:], m.Package)
	}
	if m.Version != nil {
		dAtA[i] = 0x22
		i++
		i = encodeVarintGrafeas(dAtA, i, uint64(m.Version.Size()))
		n54, err := m.Version.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n54
	}
	return i, nil
}

func encodeVarintGrafeas(dAtA []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return offset + 1
}
func (m *GetOccurrenceRequest) Size() (n int) {
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovGrafeas(uint64(l))
	}
	return n
}

func (m *ListOccurrencesRequest) Size() (n int) {
	var l int
	_ = l
	l = len(m.Filter)
	if l > 0 {
		n += 1 + l + sovGrafeas(uint64(l))
	}
	if m.PageSize != 0 {
		n += 1 + sovGrafeas(uint64(m.PageSize))
	}
	l = len(m.PageToken)
	if l > 0 {
		n += 1 + l + sovGrafeas(uint64(l))
	}
	l = len(m.Parent)
	if l > 0 {
		n += 1 + l + sovGrafeas(uint64(l))
	}
	return n
}

func (m *DeleteOccurrenceRequest) Size() (n int) {
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovGrafeas(uint64(l))
	}
	return n
}

func (m *CreateOccurrenceRequest) Size() (n int) {
	var l int
	_ = l
	if m.Occurrence != nil {
		l = m.Occurrence.Size()
		n += 1 + l + sovGrafeas(uint64(l))
	}
	l = len(m.Parent)
	if l > 0 {
		n += 1 + l + sovGrafeas(uint64(l))
	}
	return n
}

func (m *UpdateOccurrenceRequest) Size() (n int) {
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovGrafeas(uint64(l))
	}
	if m.Occurrence != nil {
		l = m.Occurrence.Size()
		n += 1 + l + sovGrafeas(uint64(l))
	}
	return n
}

func (m *GetNoteRequest) Size() (n int) {
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovGrafeas(uint64(l))
	}
	return n
}

func (m *GetOccurrenceNoteRequest) Size() (n int) {
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovGrafeas(uint64(l))
	}
	return n
}

func (m *ListNotesRequest) Size() (n int) {
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovGrafeas(uint64(l))
	}
	l = len(m.Filter)
	if l > 0 {
		n += 1 + l + sovGrafeas(uint64(l))
	}
	if m.PageSize != 0 {
		n += 1 + sovGrafeas(uint64(m.PageSize))
	}
	l = len(m.PageToken)
	if l > 0 {
		n += 1 + l + sovGrafeas(uint64(l))
	}
	l = len(m.Parent)
	if l > 0 {
		n += 1 + l + sovGrafeas(uint64(l))
	}
	return n
}

func (m *DeleteNoteRequest) Size() (n int) {
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovGrafeas(uint64(l))
	}
	return n
}

func (m *CreateNoteRequest) Size() (n int) {
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovGrafeas(uint64(l))
	}
	l = len(m.NoteId)
	if l > 0 {
		n += 1 + l + sovGrafeas(uint64(l))
	}
	if m.Note != nil {
		l = m.Note.Size()
		n += 1 + l + sovGrafeas(uint64(l))
	}
	l = len(m.Parent)
	if l > 0 {
		n += 1 + l + sovGrafeas(uint64(l))
	}
	return n
}

func (m *UpdateNoteRequest) Size() (n int) {
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovGrafeas(uint64(l))
	}
	if m.Note != nil {
		l = m.Note.Size()
		n += 1 + l + sovGrafeas(uint64(l))
	}
	return n
}

func (m *ListNoteOccurrencesRequest) Size() (n int) {
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovGrafeas(uint64(l))
	}
	l = len(m.Filter)
	if l > 0 {
		n += 1 + l + sovGrafeas(uint64(l))
	}
	if m.PageSize != 0 {
		n += 1 + sovGrafeas(uint64(m.PageSize))
	}
	l = len(m.PageToken)
	if l > 0 {
		n += 1 + l + sovGrafeas(uint64(l))
	}
	return n
}

func (m *ListNoteOccurrencesResponse) Size() (n int) {
	var l int
	_ = l
	l = len(m.NextPageToken)
	if l > 0 {
		n += 1 + l + sovGrafeas(uint64(l))
	}
	if len(m.Occurrences) > 0 {
		for _, e := range m.Occurrences {
			l = e.Size()
			n += 1 + l + sovGrafeas(uint64(l))
		}
	}
	return n
}

func (m *ListNotesResponse) Size() (n int) {
	var l int
	_ = l
	l = len(m.NextPageToken)
	if l > 0 {
		n += 1 + l + sovGrafeas(uint64(l))
	}
	if len(m.Notes) > 0 {
		for _, e := range m.Notes {
			l = e.Size()
			n += 1 + l + sovGrafeas(uint64(l))
		}
	}
	return n
}

func (m *ListOccurrencesResponse) Size() (n int) {
	var l int
	_ = l
	l = len(m.NextPageToken)
	if l > 0 {
		n += 1 + l + sovGrafeas(uint64(l))
	}
	if len(m.Occurrences) > 0 {
		for _, e := range m.Occurrences {
			l = e.Size()
			n += 1 + l + sovGrafeas(uint64(l))
		}
	}
	return n
}

func (m *ListOperationsResponse) Size() (n int) {
	var l int
	_ = l
	l = len(m.NextPageToken)
	if l > 0 {
		n += 1 + l + sovGrafeas(uint64(l))
	}
	if len(m.Operations) > 0 {
		for _, e := range m.Operations {
			l = e.Size()
			n += 1 + l + sovGrafeas(uint64(l))
		}
	}
	return n
}

func (m *UpdateOperationRequest) Size() (n int) {
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovGrafeas(uint64(l))
	}
	if m.Operation != nil {
		l = m.Operation.Size()
		n += 1 + l + sovGrafeas(uint64(l))
	}
	return n
}

func (m *CreateOperationRequest) Size() (n int) {
	var l int
	_ = l
	l = len(m.Parent)
	if l > 0 {
		n += 1 + l + sovGrafeas(uint64(l))
	}
	l = len(m.OperationId)
	if l > 0 {
		n += 1 + l + sovGrafeas(uint64(l))
	}
	if m.Operation != nil {
		l = m.Operation.Size()
		n += 1 + l + sovGrafeas(uint64(l))
	}
	return n
}

func (m *OperationMetadata) Size() (n int) {
	var l int
	_ = l
	if m.CreateTime != nil {
		l = m.CreateTime.Size()
		n += 1 + l + sovGrafeas(uint64(l))
	}
	if m.EndTime != nil {
		l = m.EndTime.Size()
		n += 1 + l + sovGrafeas(uint64(l))
	}
	return n
}

func (m *Artifact) Size() (n int) {
	var l int
	_ = l
	l = len(m.Checksum)
	if l > 0 {
		n += 1 + l + sovGrafeas(uint64(l))
	}
	l = len(m.Id)
	if l > 0 {
		n += 1 + l + sovGrafeas(uint64(l))
	}
	if len(m.Names) > 0 {
		for _, s := range m.Names {
			l = len(s)
			n += 1 + l + sovGrafeas(uint64(l))
		}
	}
	return n
}

func (m *AttestationAuthority) Size() (n int) {
	var l int
	_ = l
	if m.Hint != nil {
		l = m.Hint.Size()
		n += 1 + l + sovGrafeas(uint64(l))
	}
	return n
}

func (m *AttestationAuthority_AttestationAuthorityHint) Size() (n int) {
	var l int
	_ = l
	l = len(m.HumanReadableName)
	if l > 0 {
		n += 1 + l + sovGrafeas(uint64(l))
	}
	return n
}

func (m *AttestationAuthority_Attestation) Size() (n int) {
	var l int
	_ = l
	if m.Signature != nil {
		n += m.Signature.Size()
	}
	return n
}

func (m *AttestationAuthority_Attestation_PgpSignedAttestation) Size() (n int) {
	var l int
	_ = l
	if m.PgpSignedAttestation != nil {
		l = m.PgpSignedAttestation.Size()
		n += 1 + l + sovGrafeas(uint64(l))
	}
	return n
}
func (m *BuildDetails) Size() (n int) {
	var l int
	_ = l
	if m.Provenance != nil {
		l = m.Provenance.Size()
		n += 1 + l + sovGrafeas(uint64(l))
	}
	l = len(m.ProvenanceBytes)
	if l > 0 {
		n += 1 + l + sovGrafeas(uint64(l))
	}
	return n
}

func (m *BuildProvenance) Size() (n int) {
	var l int
	_ = l
	if len(m.BuildOptions) > 0 {
		for k, v := range m.BuildOptions {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovGrafeas(uint64(len(k))) + 1 + len(v) + sovGrafeas(uint64(len(v)))
			n += mapEntrySize + 1 + sovGrafeas(uint64(mapEntrySize))
		}
	}
	l = len(m.BuilderVersion)
	if l > 0 {
		n += 1 + l + sovGrafeas(uint64(l))
	}
	if len(m.BuiltArtifacts) > 0 {
		for _, e := range m.BuiltArtifacts {
			l = e.Size()
			n += 1 + l + sovGrafeas(uint64(l))
		}
	}
	if len(m.Commands) > 0 {
		for _, e := range m.Commands {
			l = e.Size()
			n += 1 + l + sovGrafeas(uint64(l))
		}
	}
	l = len(m.CreateTime)
	if l > 0 {
		n += 1 + l + sovGrafeas(uint64(l))
	}
	l = len(m.Creator)
	if l > 0 {
		n += 1 + l + sovGrafeas(uint64(l))
	}
	l = len(m.FinishTime)
	if l > 0 {
		n += 1 + l + sovGrafeas(uint64(l))
	}
	l = len(m.Id)
	if l > 0 {
		n += 1 + l + sovGrafeas(uint64(l))
	}
	l = len(m.LogsBucket)
	if l > 0 {
		n += 1 + l + sovGrafeas(uint64(l))
	}
	l = len(m.ProjectId)
	if l > 0 {
		n += 1 + l + sovGrafeas(uint64(l))
	}
	l = len(m.ProjectNum)
	if l > 0 {
		n += 1 + l + sovGrafeas(uint64(l))
	}
	if m.SourceProvenance != nil {
		l = m.SourceProvenance.Size()
		n += 1 + l + sovGrafeas(uint64(l))
	}
	l = len(m.StartTime)
	if l > 0 {
		n += 1 + l + sovGrafeas(uint64(l))
	}
	l = len(m.TriggerId)
	if l > 0 {
		n += 1 + l + sovGrafeas(uint64(l))
	}
	return n
}

func (m *BuildSignature) Size() (n int) {
	var l int
	_ = l
	l = len(m.KeyId)
	if l > 0 {
		n += 1 + l + sovGrafeas(uint64(l))
	}
	if m.KeyType != 0 {
		n += 1 + sovGrafeas(uint64(m.KeyType))
	}
	l = len(m.PublicKey)
	if l > 0 {
		n += 1 + l + sovGrafeas(uint64(l))
	}
	l = len(m.Signature)
	if l > 0 {
		n += 1 + l + sovGrafeas(uint64(l))
	}
	return n
}

func (m *BuildType) Size() (n int) {
	var l int
	_ = l
	l = len(m.BuilderVersion)
	if l > 0 {
		n += 1 + l + sovGrafeas(uint64(l))
	}
	if m.Signature != nil {
		l = m.Signature.Size()
		n += 1 + l + sovGrafeas(uint64(l))
	}
	return n
}

func (m *Command) Size() (n int) {
	var l int
	_ = l
	if len(m.Args) > 0 {
		for _, s := range m.Args {
			l = len(s)
			n += 1 + l + sovGrafeas(uint64(l))
		}
	}
	l = len(m.Dir)
	if l > 0 {
		n += 1 + l + sovGrafeas(uint64(l))
	}
	if len(m.Env) > 0 {
		for _, s := range m.Env {
			l = len(s)
			n += 1 + l + sovGrafeas(uint64(l))
		}
	}
	l = len(m.Id)
	if l > 0 {
		n += 1 + l + sovGrafeas(uint64(l))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovGrafeas(uint64(l))
	}
	if len(m.WaitFor) > 0 {
		for _, s := range m.WaitFor {
			l = len(s)
			n += 1 + l + sovGrafeas(uint64(l))
		}
	}
	return n
}

func (m *Deployable) Size() (n int) {
	var l int
	_ = l
	if len(m.ResourceUri) > 0 {
		for _, s := range m.ResourceUri {
			l = len(s)
			n += 1 + l + sovGrafeas(uint64(l))
		}
	}
	return n
}

func (m *Deployable_Deployment) Size() (n int) {
	var l int
	_ = l
	l = len(m.Address)
	if l > 0 {
		n += 1 + l + sovGrafeas(uint64(l))
	}
	if len(m.Config) > 0 {
		for k, v := range m.Config {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovGrafeas(uint64(len(k))) + 1 + len(v) + sovGrafeas(uint64(len(v)))
			n += mapEntrySize + 1 + sovGrafeas(uint64(mapEntrySize))
		}
	}
	l = len(m.DeployTime)
	if l > 0 {
		n += 1 + l + sovGrafeas(uint64(l))
	}
	l = len(m.UndeployTime)
	if l > 0 {
		n += 1 + l + sovGrafeas(uint64(l))
	}
	l = len(m.UserEmail)
	if l > 0 {
		n += 1 + l + sovGrafeas(uint64(l))
	}
	return n
}

func (m *DockerImage) Size() (n int) {
	var l int
	_ = l
	return n
}

func (m *DockerImage_Layer) Size() (n int) {
	var l int
	_ = l
	l = len(m.Arguments)
	if l > 0 {
		n += 1 + l + sovGrafeas(uint64(l))
	}
	if m.Directive != 0 {
		n += 1 + sovGrafeas(uint64(m.Directive))
	}
	return n
}

func (m *DockerImage_Fingerprint) Size() (n int) {
	var l int
	_ = l
	l = len(m.V1Name)
	if l > 0 {
		n += 1 + l + sovGrafeas(uint64(l))
	}
	if len(m.V2Blob) > 0 {
		for _, s := range m.V2Blob {
			l = len(s)
			n += 1 + l + sovGrafeas(uint64(l))
		}
	}
	l = len(m.V2Name)
	if l > 0 {
		n += 1 + l + sovGrafeas(uint64(l))
	}
	return n
}

func (m *DockerImage_Basis) Size() (n int) {
	var l int
	_ = l
	if m.Fingerprint != nil {
		l = m.Fingerprint.Size()
		n += 1 + l + sovGrafeas(uint64(l))
	}
	l = len(m.ResourceUrl)
	if l > 0 {
		n += 1 + l + sovGrafeas(uint64(l))
	}
	return n
}

func (m *DockerImage_Derived) Size() (n int) {
	var l int
	_ = l
	l = len(m.BaseResourceUrl)
	if l > 0 {
		n += 1 + l + sovGrafeas(uint64(l))
	}
	if m.Distance != 0 {
		n += 1 + sovGrafeas(uint64(m.Distance))
	}
	if m.Fingerprint != nil {
		l = m.Fingerprint.Size()
		n += 1 + l + sovGrafeas(uint64(l))
	}
	if len(m.LayerInfo) > 0 {
		for _, e := range m.LayerInfo {
			l = e.Size()
			n += 1 + l + sovGrafeas(uint64(l))
		}
	}
	return n
}

func (m *Discovery) Size() (n int) {
	var l int
	_ = l
	if m.AnalysisKind != 0 {
		n += 1 + sovGrafeas(uint64(m.AnalysisKind))
	}
	return n
}

func (m *Discovery_Discovered) Size() (n int) {
	var l int
	_ = l
	if m.Operation != nil {
		l = m.Operation.Size()
		n += 1 + l + sovGrafeas(uint64(l))
	}
	return n
}

func (m *FileHashes) Size() (n int) {
	var l int
	_ = l
	if len(m.FileHash) > 0 {
		for _, e := range m.FileHash {
			l = e.Size()
			n += 1 + l + sovGrafeas(uint64(l))
		}
	}
	return n
}

func (m *Hash) Size() (n int) {
	var l int
	_ = l
	if m.Type != 0 {
		n += 1 + sovGrafeas(uint64(m.Type))
	}
	l = len(m.Value)
	if l > 0 {
		n += 1 + l + sovGrafeas(uint64(l))
	}
	return n
}

func (m *Note) Size() (n int) {
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovGrafeas(uint64(l))
	}
	l = len(m.ShortDescription)
	if l > 0 {
		n += 1 + l + sovGrafeas(uint64(l))
	}
	l = len(m.LongDescription)
	if l > 0 {
		n += 1 + l + sovGrafeas(uint64(l))
	}
	if m.NoteType != nil {
		n += m.NoteType.Size()
	}
	if len(m.RelatedUrl) > 0 {
		for _, e := range m.RelatedUrl {
			l = e.Size()
			n += 1 + l + sovGrafeas(uint64(l))
		}
	}
	if m.Kind != 0 {
		n += 1 + sovGrafeas(uint64(m.Kind))
	}
	if m.ExpirationTime != nil {
		l = m.ExpirationTime.Size()
		n += 1 + l + sovGrafeas(uint64(l))
	}
	if m.CreateTime != nil {
		l = m.CreateTime.Size()
		n += 1 + l + sovGrafeas(uint64(l))
	}
	if m.UpdateTime != nil {
		l = m.UpdateTime.Size()
		n += 1 + l + sovGrafeas(uint64(l))
	}
	l = len(m.OperationName)
	if l > 0 {
		n += 1 + l + sovGrafeas(uint64(l))
	}
	return n
}

func (m *Note_VulnerabilityType) Size() (n int) {
	var l int
	_ = l
	if m.VulnerabilityType != nil {
		l = m.VulnerabilityType.Size()
		n += 1 + l + sovGrafeas(uint64(l))
	}
	return n
}
func (m *Note_BuildType) Size() (n int) {
	var l int
	_ = l
	if m.BuildType != nil {
		l = m.BuildType.Size()
		n += 1 + l + sovGrafeas(uint64(l))
	}
	return n
}
func (m *Note_BaseImage) Size() (n int) {
	var l int
	_ = l
	if m.BaseImage != nil {
		l = m.BaseImage.Size()
		n += 1 + l + sovGrafeas(uint64(l))
	}
	return n
}
func (m *Note_Package) Size() (n int) {
	var l int
	_ = l
	if m.Package != nil {
		l = m.Package.Size()
		n += 1 + l + sovGrafeas(uint64(l))
	}
	return n
}
func (m *Note_Deployable) Size() (n int) {
	var l int
	_ = l
	if m.Deployable != nil {
		l = m.Deployable.Size()
		n += 2 + l + sovGrafeas(uint64(l))
	}
	return n
}
func (m *Note_Discovery) Size() (n int) {
	var l int
	_ = l
	if m.Discovery != nil {
		l = m.Discovery.Size()
		n += 2 + l + sovGrafeas(uint64(l))
	}
	return n
}
func (m *Note_AttestationAuthority) Size() (n int) {
	var l int
	_ = l
	if m.AttestationAuthority != nil {
		l = m.AttestationAuthority.Size()
		n += 2 + l + sovGrafeas(uint64(l))
	}
	return n
}
func (m *Note_RelatedUrl) Size() (n int) {
	var l int
	_ = l
	l = len(m.Url)
	if l > 0 {
		n += 1 + l + sovGrafeas(uint64(l))
	}
	l = len(m.Label)
	if l > 0 {
		n += 1 + l + sovGrafeas(uint64(l))
	}
	return n
}

func (m *Occurrence) Size() (n int) {
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovGrafeas(uint64(l))
	}
	l = len(m.ResourceUrl)
	if l > 0 {
		n += 1 + l + sovGrafeas(uint64(l))
	}
	l = len(m.NoteName)
	if l > 0 {
		n += 1 + l + sovGrafeas(uint64(l))
	}
	l = len(m.Remediation)
	if l > 0 {
		n += 1 + l + sovGrafeas(uint64(l))
	}
	if m.Kind != 0 {
		n += 1 + sovGrafeas(uint64(m.Kind))
	}
	if m.Details != nil {
		n += m.Details.Size()
	}
	if m.CreateTime != nil {
		l = m.CreateTime.Size()
		n += 1 + l + sovGrafeas(uint64(l))
	}
	if m.UpdateTime != nil {
		l = m.UpdateTime.Size()
		n += 1 + l + sovGrafeas(uint64(l))
	}
	l = len(m.OperationName)
	if l > 0 {
		n += 1 + l + sovGrafeas(uint64(l))
	}
	return n
}

func (m *Occurrence_BuildDetails) Size() (n int) {
	var l int
	_ = l
	if m.BuildDetails != nil {
		l = m.BuildDetails.Size()
		n += 1 + l + sovGrafeas(uint64(l))
	}
	return n
}
func (m *Occurrence_VulnerabilityDetails) Size() (n int) {
	var l int
	_ = l
	if m.VulnerabilityDetails != nil {
		l = m.VulnerabilityDetails.Size()
		n += 1 + l + sovGrafeas(uint64(l))
	}
	return n
}
func (m *Occurrence_DerivedImage) Size() (n int) {
	var l int
	_ = l
	if m.DerivedImage != nil {
		l = m.DerivedImage.Size()
		n += 1 + l + sovGrafeas(uint64(l))
	}
	return n
}
func (m *Occurrence_Installation) Size() (n int) {
	var l int
	_ = l
	if m.Installation != nil {
		l = m.Installation.Size()
		n += 1 + l + sovGrafeas(uint64(l))
	}
	return n
}
func (m *Occurrence_Deployment) Size() (n int) {
	var l int
	_ = l
	if m.Deployment != nil {
		l = m.Deployment.Size()
		n += 1 + l + sovGrafeas(uint64(l))
	}
	return n
}
func (m *Occurrence_Discovered) Size() (n int) {
	var l int
	_ = l
	if m.Discovered != nil {
		l = m.Discovered.Size()
		n += 1 + l + sovGrafeas(uint64(l))
	}
	return n
}
func (m *Occurrence_Attestation) Size() (n int) {
	var l int
	_ = l
	if m.Attestation != nil {
		l = m.Attestation.Size()
		n += 2 + l + sovGrafeas(uint64(l))
	}
	return n
}
func (m *PackageManager) Size() (n int) {
	var l int
	_ = l
	return n
}

func (m *PackageManager_Package) Size() (n int) {
	var l int
	_ = l
	if len(m.Distribution) > 0 {
		for _, e := range m.Distribution {
			l = e.Size()
			n += 1 + l + sovGrafeas(uint64(l))
		}
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovGrafeas(uint64(l))
	}
	return n
}

func (m *PackageManager_Distribution) Size() (n int) {
	var l int
	_ = l
	if m.Architecture != 0 {
		n += 1 + sovGrafeas(uint64(m.Architecture))
	}
	l = len(m.CpeUri)
	if l > 0 {
		n += 1 + l + sovGrafeas(uint64(l))
	}
	l = len(m.Description)
	if l > 0 {
		n += 1 + l + sovGrafeas(uint64(l))
	}
	if m.LatestVersion != nil {
		l = m.LatestVersion.Size()
		n += 1 + l + sovGrafeas(uint64(l))
	}
	l = len(m.Maintainer)
	if l > 0 {
		n += 1 + l + sovGrafeas(uint64(l))
	}
	l = len(m.Url)
	if l > 0 {
		n += 1 + l + sovGrafeas(uint64(l))
	}
	return n
}

func (m *PackageManager_Version) Size() (n int) {
	var l int
	_ = l
	if m.Epoch != 0 {
		n += 1 + sovGrafeas(uint64(m.Epoch))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovGrafeas(uint64(l))
	}
	l = len(m.Revision)
	if l > 0 {
		n += 1 + l + sovGrafeas(uint64(l))
	}
	if m.Kind != 0 {
		n += 1 + sovGrafeas(uint64(m.Kind))
	}
	return n
}

func (m *PackageManager_Location) Size() (n int) {
	var l int
	_ = l
	l = len(m.CpeUri)
	if l > 0 {
		n += 1 + l + sovGrafeas(uint64(l))
	}
	l = len(m.Path)
	if l > 0 {
		n += 1 + l + sovGrafeas(uint64(l))
	}
	if m.Version != nil {
		l = m.Version.Size()
		n += 1 + l + sovGrafeas(uint64(l))
	}
	return n
}

func (m *PackageManager_Installation) Size() (n int) {
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovGrafeas(uint64(l))
	}
	if len(m.Location) > 0 {
		for _, e := range m.Location {
			l = e.Size()
			n += 1 + l + sovGrafeas(uint64(l))
		}
	}
	return n
}

func (m *PgpSignedAttestation) Size() (n int) {
	var l int
	_ = l
	l = len(m.Signature)
	if l > 0 {
		n += 1 + l + sovGrafeas(uint64(l))
	}
	if m.KeyId != nil {
		n += m.KeyId.Size()
	}
	if m.ContentType != 0 {
		n += 1 + sovGrafeas(uint64(m.ContentType))
	}
	return n
}

func (m *PgpSignedAttestation_PgpKeyId) Size() (n int) {
	var l int
	_ = l
	l = len(m.PgpKeyId)
	n += 1 + l + sovGrafeas(uint64(l))
	return n
}
func (m *Source) Size() (n int) {
	var l int
	_ = l
	if m.Source != nil {
		n += m.Source.Size()
	}
	if len(m.FileHashes) > 0 {
		for k, v := range m.FileHashes {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.Size()
				l += 1 + sovGrafeas(uint64(l))
			}
			mapEntrySize := 1 + len(k) + sovGrafeas(uint64(len(k))) + l
			n += mapEntrySize + 1 + sovGrafeas(uint64(mapEntrySize))
		}
	}
	if m.ArtifactStorageSource != nil {
		l = m.ArtifactStorageSource.Size()
		n += 1 + l + sovGrafeas(uint64(l))
	}
	if m.SourceContext != nil {
		l = m.SourceContext.Size()
		n += 1 + l + sovGrafeas(uint64(l))
	}
	if len(m.AdditionalSourceContexts) > 0 {
		for _, e := range m.AdditionalSourceContexts {
			l = e.Size()
			n += 1 + l + sovGrafeas(uint64(l))
		}
	}
	return n
}

func (m *Source_StorageSource) Size() (n int) {
	var l int
	_ = l
	if m.StorageSource != nil {
		l = m.StorageSource.Size()
		n += 1 + l + sovGrafeas(uint64(l))
	}
	return n
}
func (m *Source_RepoSource) Size() (n int) {
	var l int
	_ = l
	if m.RepoSource != nil {
		l = m.RepoSource.Size()
		n += 1 + l + sovGrafeas(uint64(l))
	}
	return n
}
func (m *RepoSource) Size() (n int) {
	var l int
	_ = l
	l = len(m.ProjectId)
	if l > 0 {
		n += 1 + l + sovGrafeas(uint64(l))
	}
	l = len(m.RepoName)
	if l > 0 {
		n += 1 + l + sovGrafeas(uint64(l))
	}
	if m.Revision != nil {
		n += m.Revision.Size()
	}
	return n
}

func (m *RepoSource_BranchName) Size() (n int) {
	var l int
	_ = l
	l = len(m.BranchName)
	n += 1 + l + sovGrafeas(uint64(l))
	return n
}
func (m *RepoSource_TagName) Size() (n int) {
	var l int
	_ = l
	l = len(m.TagName)
	n += 1 + l + sovGrafeas(uint64(l))
	return n
}
func (m *RepoSource_CommitSha) Size() (n int) {
	var l int
	_ = l
	l = len(m.CommitSha)
	n += 1 + l + sovGrafeas(uint64(l))
	return n
}
func (m *StorageSource) Size() (n int) {
	var l int
	_ = l
	l = len(m.Bucket)
	if l > 0 {
		n += 1 + l + sovGrafeas(uint64(l))
	}
	l = len(m.Generation)
	if l > 0 {
		n += 1 + l + sovGrafeas(uint64(l))
	}
	l = len(m.Object)
	if l > 0 {
		n += 1 + l + sovGrafeas(uint64(l))
	}
	return n
}

func (m *VulnerabilityType) Size() (n int) {
	var l int
	_ = l
	if m.CvssScore != 0 {
		n += 5
	}
	if m.Severity != 0 {
		n += 1 + sovGrafeas(uint64(m.Severity))
	}
	if len(m.Details) > 0 {
		for _, e := range m.Details {
			l = e.Size()
			n += 1 + l + sovGrafeas(uint64(l))
		}
	}
	return n
}

func (m *VulnerabilityType_Version) Size() (n int) {
	var l int
	_ = l
	if m.Epoch != 0 {
		n += 1 + sovGrafeas(uint64(m.Epoch))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovGrafeas(uint64(l))
	}
	l = len(m.Revision)
	if l > 0 {
		n += 1 + l + sovGrafeas(uint64(l))
	}
	if m.Kind != 0 {
		n += 1 + sovGrafeas(uint64(m.Kind))
	}
	return n
}

func (m *VulnerabilityType_Detail) Size() (n int) {
	var l int
	_ = l
	l = len(m.CpeUri)
	if l > 0 {
		n += 1 + l + sovGrafeas(uint64(l))
	}
	l = len(m.SeverityName)
	if l > 0 {
		n += 1 + l + sovGrafeas(uint64(l))
	}
	if m.FixedLocation != nil {
		l = m.FixedLocation.Size()
		n += 1 + l + sovGrafeas(uint64(l))
	}
	if m.MinAffectedVersion != nil {
		l = m.MinAffectedVersion.Size()
		n += 1 + l + sovGrafeas(uint64(l))
	}
	if m.MaxAffectedVersion != nil {
		l = m.MaxAffectedVersion.Size()
		n += 1 + l + sovGrafeas(uint64(l))
	}
	l = len(m.Package)
	if l > 0 {
		n += 1 + l + sovGrafeas(uint64(l))
	}
	l = len(m.Description)
	if l > 0 {
		n += 1 + l + sovGrafeas(uint64(l))
	}
	l = len(m.PackageType)
	if l > 0 {
		n += 1 + l + sovGrafeas(uint64(l))
	}
	return n
}

func (m *VulnerabilityType_VulnerabilityDetails) Size() (n int) {
	var l int
	_ = l
	l = len(m.Type)
	if l > 0 {
		n += 1 + l + sovGrafeas(uint64(l))
	}
	if m.Severity != 0 {
		n += 1 + sovGrafeas(uint64(m.Severity))
	}
	if m.CvssScore != 0 {
		n += 5
	}
	if len(m.PackageIssue) > 0 {
		for _, e := range m.PackageIssue {
			l = e.Size()
			n += 1 + l + sovGrafeas(uint64(l))
		}
	}
	return n
}

func (m *VulnerabilityType_PackageIssue) Size() (n int) {
	var l int
	_ = l
	if m.AffectedLocation != nil {
		l = m.AffectedLocation.Size()
		n += 1 + l + sovGrafeas(uint64(l))
	}
	if m.FixedLocation != nil {
		l = m.FixedLocation.Size()
		n += 1 + l + sovGrafeas(uint64(l))
	}
	l = len(m.SeverityName)
	if l > 0 {
		n += 1 + l + sovGrafeas(uint64(l))
	}
	return n
}

func (m *VulnerabilityType_VulnerabilityLocation) Size() (n int) {
	var l int
	_ = l
	l = len(m.CpeUri)
	if l > 0 {
		n += 1 + l + sovGrafeas(uint64(l))
	}
	l = len(m.Package)
	if l > 0 {
		n += 1 + l + sovGrafeas(uint64(l))
	}
	if m.Version != nil {
		l = m.Version.Size()
		n += 1 + l + sovGrafeas(uint64(l))
	}
	return n
}

func sovGrafeas(x uint64) (n int) {
	for {
		n++
		x >>= 7
		if x == 0 {
			break
		}
	}
	return n
}
func sozGrafeas(x uint64) (n int) {
	return sovGrafeas(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *GetOccurrenceRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGrafeas
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetOccurrenceRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetOccurrenceRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGrafeas
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGrafeas
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGrafeas(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGrafeas
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ListOccurrencesRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGrafeas
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ListOccurrencesRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ListOccurrencesRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Filter", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGrafeas
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGrafeas
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Filter = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PageSize", wireType)
			}
			m.PageSize = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGrafeas
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PageSize |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PageToken", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGrafeas
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGrafeas
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PageToken = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Parent", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGrafeas
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGrafeas
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Parent = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGrafeas(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGrafeas
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DeleteOccurrenceRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGrafeas
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DeleteOccurrenceRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DeleteOccurrenceRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGrafeas
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGrafeas
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGrafeas(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGrafeas
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CreateOccurrenceRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGrafeas
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CreateOccurrenceRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CreateOccurrenceRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Occurrence", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGrafeas
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGrafeas
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Occurrence == nil {
				m.Occurrence = &Occurrence{}
			}
			if err := m.Occurrence.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Parent", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGrafeas
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGrafeas
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Parent = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGrafeas(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGrafeas
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UpdateOccurrenceRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGrafeas
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UpdateOccurrenceRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UpdateOccurrenceRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGrafeas
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGrafeas
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Occurrence", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGrafeas
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGrafeas
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Occurrence == nil {
				m.Occurrence = &Occurrence{}
			}
			if err := m.Occurrence.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGrafeas(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGrafeas
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetNoteRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGrafeas
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetNoteRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetNoteRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGrafeas
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGrafeas
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGrafeas(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGrafeas
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetOccurrenceNoteRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGrafeas
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetOccurrenceNoteRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetOccurrenceNoteRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGrafeas
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGrafeas
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGrafeas(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGrafeas
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ListNotesRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGrafeas
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ListNotesRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ListNotesRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGrafeas
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGrafeas
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Filter", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGrafeas
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGrafeas
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Filter = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PageSize", wireType)
			}
			m.PageSize = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGrafeas
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PageSize |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PageToken", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGrafeas
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGrafeas
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PageToken = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Parent", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGrafeas
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGrafeas
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Parent = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGrafeas(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGrafeas
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DeleteNoteRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGrafeas
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DeleteNoteRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DeleteNoteRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGrafeas
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGrafeas
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGrafeas(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGrafeas
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CreateNoteRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGrafeas
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CreateNoteRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CreateNoteRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGrafeas
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGrafeas
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NoteId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGrafeas
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGrafeas
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NoteId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Note", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGrafeas
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGrafeas
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Note == nil {
				m.Note = &Note{}
			}
			if err := m.Note.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Parent", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGrafeas
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGrafeas
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Parent = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGrafeas(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGrafeas
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UpdateNoteRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGrafeas
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UpdateNoteRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UpdateNoteRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGrafeas
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGrafeas
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Note", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGrafeas
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGrafeas
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Note == nil {
				m.Note = &Note{}
			}
			if err := m.Note.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGrafeas(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGrafeas
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ListNoteOccurrencesRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGrafeas
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ListNoteOccurrencesRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ListNoteOccurrencesRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGrafeas
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGrafeas
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Filter", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGrafeas
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGrafeas
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Filter = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PageSize", wireType)
			}
			m.PageSize = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGrafeas
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PageSize |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PageToken", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGrafeas
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGrafeas
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PageToken = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGrafeas(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGrafeas
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ListNoteOccurrencesResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGrafeas
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ListNoteOccurrencesResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ListNoteOccurrencesResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NextPageToken", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGrafeas
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGrafeas
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NextPageToken = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Occurrences", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGrafeas
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGrafeas
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Occurrences = append(m.Occurrences, &Occurrence{})
			if err := m.Occurrences[len(m.Occurrences)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGrafeas(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGrafeas
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ListNotesResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGrafeas
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ListNotesResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ListNotesResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NextPageToken", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGrafeas
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGrafeas
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NextPageToken = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Notes", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGrafeas
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGrafeas
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Notes = append(m.Notes, &Note{})
			if err := m.Notes[len(m.Notes)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGrafeas(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGrafeas
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ListOccurrencesResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGrafeas
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ListOccurrencesResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ListOccurrencesResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NextPageToken", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGrafeas
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGrafeas
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NextPageToken = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Occurrences", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGrafeas
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGrafeas
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Occurrences = append(m.Occurrences, &Occurrence{})
			if err := m.Occurrences[len(m.Occurrences)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGrafeas(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGrafeas
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ListOperationsResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGrafeas
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ListOperationsResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ListOperationsResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NextPageToken", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGrafeas
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGrafeas
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NextPageToken = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Operations", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGrafeas
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGrafeas
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Operations = append(m.Operations, &google_longrunning.Operation{})
			if err := m.Operations[len(m.Operations)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGrafeas(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGrafeas
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UpdateOperationRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGrafeas
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UpdateOperationRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UpdateOperationRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGrafeas
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGrafeas
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Operation", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGrafeas
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGrafeas
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Operation == nil {
				m.Operation = &google_longrunning.Operation{}
			}
			if err := m.Operation.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGrafeas(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGrafeas
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CreateOperationRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGrafeas
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CreateOperationRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CreateOperationRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Parent", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGrafeas
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGrafeas
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Parent = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OperationId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGrafeas
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGrafeas
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OperationId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Operation", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGrafeas
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGrafeas
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Operation == nil {
				m.Operation = &google_longrunning.Operation{}
			}
			if err := m.Operation.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGrafeas(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGrafeas
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *OperationMetadata) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGrafeas
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: OperationMetadata: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: OperationMetadata: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CreateTime", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGrafeas
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGrafeas
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.CreateTime == nil {
				m.CreateTime = &google_protobuf2.Timestamp{}
			}
			if err := m.CreateTime.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EndTime", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGrafeas
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGrafeas
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.EndTime == nil {
				m.EndTime = &google_protobuf2.Timestamp{}
			}
			if err := m.EndTime.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGrafeas(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGrafeas
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Artifact) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGrafeas
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Artifact: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Artifact: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Checksum", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGrafeas
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGrafeas
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Checksum = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGrafeas
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGrafeas
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Id = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Names", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGrafeas
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGrafeas
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Names = append(m.Names, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGrafeas(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGrafeas
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AttestationAuthority) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGrafeas
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AttestationAuthority: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AttestationAuthority: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Hint", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGrafeas
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGrafeas
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Hint == nil {
				m.Hint = &AttestationAuthority_AttestationAuthorityHint{}
			}
			if err := m.Hint.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGrafeas(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGrafeas
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AttestationAuthority_AttestationAuthorityHint) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGrafeas
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AttestationAuthorityHint: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AttestationAuthorityHint: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field HumanReadableName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGrafeas
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGrafeas
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.HumanReadableName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGrafeas(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGrafeas
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AttestationAuthority_Attestation) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGrafeas
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Attestation: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Attestation: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PgpSignedAttestation", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGrafeas
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGrafeas
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &PgpSignedAttestation{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Signature = &AttestationAuthority_Attestation_PgpSignedAttestation{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGrafeas(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGrafeas
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BuildDetails) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGrafeas
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BuildDetails: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BuildDetails: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Provenance", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGrafeas
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGrafeas
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Provenance == nil {
				m.Provenance = &BuildProvenance{}
			}
			if err := m.Provenance.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProvenanceBytes", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGrafeas
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGrafeas
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ProvenanceBytes = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGrafeas(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGrafeas
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BuildProvenance) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGrafeas
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BuildProvenance: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BuildProvenance: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BuildOptions", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGrafeas
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGrafeas
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.BuildOptions == nil {
				m.BuildOptions = make(map[string]string)
			}
			var mapkey string
			var mapvalue string
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowGrafeas
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowGrafeas
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= (uint64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthGrafeas
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var stringLenmapvalue uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowGrafeas
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapvalue |= (uint64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapvalue := int(stringLenmapvalue)
					if intStringLenmapvalue < 0 {
						return ErrInvalidLengthGrafeas
					}
					postStringIndexmapvalue := iNdEx + intStringLenmapvalue
					if postStringIndexmapvalue > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = string(dAtA[iNdEx:postStringIndexmapvalue])
					iNdEx = postStringIndexmapvalue
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipGrafeas(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthGrafeas
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.BuildOptions[mapkey] = mapvalue
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BuilderVersion", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGrafeas
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGrafeas
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BuilderVersion = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BuiltArtifacts", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGrafeas
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGrafeas
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BuiltArtifacts = append(m.BuiltArtifacts, &Artifact{})
			if err := m.BuiltArtifacts[len(m.BuiltArtifacts)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Commands", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGrafeas
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGrafeas
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Commands = append(m.Commands, &Command{})
			if err := m.Commands[len(m.Commands)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CreateTime", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGrafeas
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGrafeas
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CreateTime = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Creator", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGrafeas
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGrafeas
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Creator = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FinishTime", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGrafeas
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGrafeas
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FinishTime = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGrafeas
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGrafeas
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Id = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LogsBucket", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGrafeas
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGrafeas
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.LogsBucket = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProjectId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGrafeas
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGrafeas
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ProjectId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProjectNum", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGrafeas
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGrafeas
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ProjectNum = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SourceProvenance", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGrafeas
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGrafeas
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.SourceProvenance == nil {
				m.SourceProvenance = &Source{}
			}
			if err := m.SourceProvenance.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StartTime", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGrafeas
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGrafeas
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.StartTime = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 14:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TriggerId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGrafeas
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGrafeas
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TriggerId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGrafeas(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGrafeas
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BuildSignature) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGrafeas
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BuildSignature: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BuildSignature: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field KeyId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGrafeas
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGrafeas
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.KeyId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field KeyType", wireType)
			}
			m.KeyType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGrafeas
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.KeyType |= (BuildSignature_KeyType(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PublicKey", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGrafeas
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGrafeas
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PublicKey = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Signature", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGrafeas
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGrafeas
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Signature = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGrafeas(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGrafeas
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BuildType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGrafeas
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BuildType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BuildType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BuilderVersion", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGrafeas
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGrafeas
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BuilderVersion = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Signature", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGrafeas
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGrafeas
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Signature == nil {
				m.Signature = &BuildSignature{}
			}
			if err := m.Signature.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGrafeas(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGrafeas
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Command) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGrafeas
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Command: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Command: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Args", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGrafeas
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGrafeas
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Args = append(m.Args, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Dir", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGrafeas
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGrafeas
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Dir = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Env", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGrafeas
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGrafeas
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Env = append(m.Env, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGrafeas
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGrafeas
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Id = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGrafeas
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGrafeas
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field WaitFor", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGrafeas
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGrafeas
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.WaitFor = append(m.WaitFor, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGrafeas(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGrafeas
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Deployable) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGrafeas
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Deployable: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Deployable: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ResourceUri", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGrafeas
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGrafeas
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ResourceUri = append(m.ResourceUri, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGrafeas(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGrafeas
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Deployable_Deployment) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGrafeas
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Deployment: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Deployment: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Address", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGrafeas
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGrafeas
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Address = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Config", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGrafeas
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGrafeas
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Config == nil {
				m.Config = make(map[string]string)
			}
			var mapkey string
			var mapvalue string
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowGrafeas
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowGrafeas
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= (uint64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthGrafeas
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var stringLenmapvalue uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowGrafeas
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapvalue |= (uint64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapvalue := int(stringLenmapvalue)
					if intStringLenmapvalue < 0 {
						return ErrInvalidLengthGrafeas
					}
					postStringIndexmapvalue := iNdEx + intStringLenmapvalue
					if postStringIndexmapvalue > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = string(dAtA[iNdEx:postStringIndexmapvalue])
					iNdEx = postStringIndexmapvalue
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipGrafeas(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthGrafeas
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Config[mapkey] = mapvalue
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DeployTime", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGrafeas
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGrafeas
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DeployTime = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UndeployTime", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGrafeas
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGrafeas
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.UndeployTime = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserEmail", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGrafeas
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGrafeas
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.UserEmail = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGrafeas(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGrafeas
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DockerImage) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGrafeas
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DockerImage: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DockerImage: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipGrafeas(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGrafeas
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DockerImage_Layer) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGrafeas
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Layer: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Layer: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Arguments", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGrafeas
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGrafeas
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Arguments = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Directive", wireType)
			}
			m.Directive = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGrafeas
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Directive |= (DockerImage_Layer_Directive(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipGrafeas(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGrafeas
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DockerImage_Fingerprint) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGrafeas
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Fingerprint: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Fingerprint: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field V1Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGrafeas
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGrafeas
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.V1Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field V2Blob", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGrafeas
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGrafeas
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.V2Blob = append(m.V2Blob, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field V2Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGrafeas
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGrafeas
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.V2Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGrafeas(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGrafeas
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DockerImage_Basis) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGrafeas
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Basis: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Basis: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Fingerprint", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGrafeas
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGrafeas
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Fingerprint == nil {
				m.Fingerprint = &DockerImage_Fingerprint{}
			}
			if err := m.Fingerprint.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ResourceUrl", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGrafeas
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGrafeas
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ResourceUrl = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGrafeas(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGrafeas
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DockerImage_Derived) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGrafeas
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Derived: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Derived: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BaseResourceUrl", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGrafeas
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGrafeas
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BaseResourceUrl = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Distance", wireType)
			}
			m.Distance = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGrafeas
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Distance |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Fingerprint", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGrafeas
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGrafeas
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Fingerprint == nil {
				m.Fingerprint = &DockerImage_Fingerprint{}
			}
			if err := m.Fingerprint.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LayerInfo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGrafeas
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGrafeas
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.LayerInfo = append(m.LayerInfo, &DockerImage_Layer{})
			if err := m.LayerInfo[len(m.LayerInfo)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGrafeas(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGrafeas
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Discovery) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGrafeas
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Discovery: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Discovery: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AnalysisKind", wireType)
			}
			m.AnalysisKind = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGrafeas
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AnalysisKind |= (Note_Kind(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipGrafeas(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGrafeas
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Discovery_Discovered) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGrafeas
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Discovered: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Discovered: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Operation", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGrafeas
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGrafeas
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Operation == nil {
				m.Operation = &google_longrunning.Operation{}
			}
			if err := m.Operation.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGrafeas(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGrafeas
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FileHashes) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGrafeas
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FileHashes: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FileHashes: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FileHash", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGrafeas
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGrafeas
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FileHash = append(m.FileHash, &Hash{})
			if err := m.FileHash[len(m.FileHash)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGrafeas(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGrafeas
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Hash) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGrafeas
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Hash: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Hash: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGrafeas
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= (Hash_Type(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Value", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGrafeas
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGrafeas
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Value = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGrafeas(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGrafeas
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Note) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGrafeas
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Note: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Note: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGrafeas
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGrafeas
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ShortDescription", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGrafeas
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGrafeas
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ShortDescription = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LongDescription", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGrafeas
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGrafeas
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.LongDescription = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VulnerabilityType", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGrafeas
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGrafeas
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &VulnerabilityType{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.NoteType = &Note_VulnerabilityType{v}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RelatedUrl", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGrafeas
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGrafeas
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RelatedUrl = append(m.RelatedUrl, &Note_RelatedUrl{})
			if err := m.RelatedUrl[len(m.RelatedUrl)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BuildType", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGrafeas
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGrafeas
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &BuildType{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.NoteType = &Note_BuildType{v}
			iNdEx = postIndex
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Kind", wireType)
			}
			m.Kind = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGrafeas
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Kind |= (Note_Kind(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExpirationTime", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGrafeas
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGrafeas
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ExpirationTime == nil {
				m.ExpirationTime = &google_protobuf2.Timestamp{}
			}
			if err := m.ExpirationTime.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CreateTime", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGrafeas
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGrafeas
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.CreateTime == nil {
				m.CreateTime = &google_protobuf2.Timestamp{}
			}
			if err := m.CreateTime.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UpdateTime", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGrafeas
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGrafeas
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.UpdateTime == nil {
				m.UpdateTime = &google_protobuf2.Timestamp{}
			}
			if err := m.UpdateTime.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BaseImage", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGrafeas
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGrafeas
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &DockerImage_Basis{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.NoteType = &Note_BaseImage{v}
			iNdEx = postIndex
		case 14:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Package", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGrafeas
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGrafeas
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &PackageManager_Package{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.NoteType = &Note_Package{v}
			iNdEx = postIndex
		case 15:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OperationName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGrafeas
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGrafeas
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OperationName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 17:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Deployable", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGrafeas
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGrafeas
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &Deployable{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.NoteType = &Note_Deployable{v}
			iNdEx = postIndex
		case 18:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Discovery", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGrafeas
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGrafeas
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &Discovery{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.NoteType = &Note_Discovery{v}
			iNdEx = postIndex
		case 19:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AttestationAuthority", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGrafeas
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGrafeas
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &AttestationAuthority{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.NoteType = &Note_AttestationAuthority{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGrafeas(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGrafeas
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Note_RelatedUrl) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGrafeas
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RelatedUrl: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RelatedUrl: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Url", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGrafeas
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGrafeas
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Url = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Label", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGrafeas
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGrafeas
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Label = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGrafeas(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGrafeas
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Occurrence) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGrafeas
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Occurrence: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Occurrence: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGrafeas
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGrafeas
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ResourceUrl", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGrafeas
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGrafeas
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ResourceUrl = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NoteName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGrafeas
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGrafeas
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NoteName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Remediation", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGrafeas
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGrafeas
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Remediation = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Kind", wireType)
			}
			m.Kind = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGrafeas
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Kind |= (Note_Kind(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BuildDetails", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGrafeas
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGrafeas
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &BuildDetails{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Details = &Occurrence_BuildDetails{v}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VulnerabilityDetails", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGrafeas
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGrafeas
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &VulnerabilityType_VulnerabilityDetails{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Details = &Occurrence_VulnerabilityDetails{v}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CreateTime", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGrafeas
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGrafeas
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.CreateTime == nil {
				m.CreateTime = &google_protobuf2.Timestamp{}
			}
			if err := m.CreateTime.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UpdateTime", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGrafeas
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGrafeas
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.UpdateTime == nil {
				m.UpdateTime = &google_protobuf2.Timestamp{}
			}
			if err := m.UpdateTime.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DerivedImage", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGrafeas
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGrafeas
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &DockerImage_Derived{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Details = &Occurrence_DerivedImage{v}
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Installation", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGrafeas
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGrafeas
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &PackageManager_Installation{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Details = &Occurrence_Installation{v}
			iNdEx = postIndex
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OperationName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGrafeas
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGrafeas
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OperationName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 14:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Deployment", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGrafeas
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGrafeas
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &Deployable_Deployment{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Details = &Occurrence_Deployment{v}
			iNdEx = postIndex
		case 15:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Discovered", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGrafeas
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGrafeas
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &Discovery_Discovered{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Details = &Occurrence_Discovered{v}
			iNdEx = postIndex
		case 16:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Attestation", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGrafeas
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGrafeas
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &AttestationAuthority_Attestation{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Details = &Occurrence_Attestation{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGrafeas(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGrafeas
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PackageManager) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGrafeas
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PackageManager: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PackageManager: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipGrafeas(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGrafeas
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PackageManager_Package) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGrafeas
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Package: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Package: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Distribution", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGrafeas
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGrafeas
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Distribution = append(m.Distribution, &PackageManager_Distribution{})
			if err := m.Distribution[len(m.Distribution)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGrafeas
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGrafeas
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGrafeas(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGrafeas
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PackageManager_Distribution) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGrafeas
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Distribution: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Distribution: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Architecture", wireType)
			}
			m.Architecture = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGrafeas
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Architecture |= (PackageManager_Distribution_Architecture(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CpeUri", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGrafeas
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGrafeas
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CpeUri = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Description", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGrafeas
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGrafeas
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Description = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LatestVersion", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGrafeas
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGrafeas
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.LatestVersion == nil {
				m.LatestVersion = &PackageManager_Version{}
			}
			if err := m.LatestVersion.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Maintainer", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGrafeas
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGrafeas
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Maintainer = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Url", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGrafeas
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGrafeas
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Url = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGrafeas(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGrafeas
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PackageManager_Version) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGrafeas
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Version: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Version: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Epoch", wireType)
			}
			m.Epoch = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGrafeas
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Epoch |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGrafeas
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGrafeas
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Revision", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGrafeas
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGrafeas
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Revision = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Kind", wireType)
			}
			m.Kind = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGrafeas
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Kind |= (PackageManager_Version_VersionKind(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipGrafeas(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGrafeas
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PackageManager_Location) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGrafeas
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Location: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Location: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CpeUri", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGrafeas
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGrafeas
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CpeUri = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Path", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGrafeas
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGrafeas
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Path = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Version", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGrafeas
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGrafeas
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Version == nil {
				m.Version = &VulnerabilityType_Version{}
			}
			if err := m.Version.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGrafeas(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGrafeas
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PackageManager_Installation) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGrafeas
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Installation: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Installation: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGrafeas
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGrafeas
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Location", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGrafeas
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGrafeas
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Location = append(m.Location, &PackageManager_Location{})
			if err := m.Location[len(m.Location)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGrafeas(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGrafeas
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PgpSignedAttestation) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGrafeas
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PgpSignedAttestation: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PgpSignedAttestation: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Signature", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGrafeas
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGrafeas
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Signature = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PgpKeyId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGrafeas
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGrafeas
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.KeyId = &PgpSignedAttestation_PgpKeyId{string(dAtA[iNdEx:postIndex])}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ContentType", wireType)
			}
			m.ContentType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGrafeas
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ContentType |= (PgpSignedAttestation_ContentType(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipGrafeas(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGrafeas
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Source) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGrafeas
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Source: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Source: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StorageSource", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGrafeas
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGrafeas
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &StorageSource{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Source = &Source_StorageSource{v}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RepoSource", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGrafeas
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGrafeas
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &RepoSource{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Source = &Source_RepoSource{v}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FileHashes", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGrafeas
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGrafeas
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.FileHashes == nil {
				m.FileHashes = make(map[string]*FileHashes)
			}
			var mapkey string
			var mapvalue *FileHashes
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowGrafeas
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowGrafeas
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= (uint64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthGrafeas
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var mapmsglen int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowGrafeas
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapmsglen |= (int(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					if mapmsglen < 0 {
						return ErrInvalidLengthGrafeas
					}
					postmsgIndex := iNdEx + mapmsglen
					if mapmsglen < 0 {
						return ErrInvalidLengthGrafeas
					}
					if postmsgIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = &FileHashes{}
					if err := mapvalue.Unmarshal(dAtA[iNdEx:postmsgIndex]); err != nil {
						return err
					}
					iNdEx = postmsgIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipGrafeas(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthGrafeas
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.FileHashes[mapkey] = mapvalue
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ArtifactStorageSource", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGrafeas
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGrafeas
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ArtifactStorageSource == nil {
				m.ArtifactStorageSource = &StorageSource{}
			}
			if err := m.ArtifactStorageSource.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SourceContext", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGrafeas
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGrafeas
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.SourceContext == nil {
				m.SourceContext = &google_devtools_source_v1.ExtendedSourceContext{}
			}
			if err := m.SourceContext.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AdditionalSourceContexts", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGrafeas
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGrafeas
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AdditionalSourceContexts = append(m.AdditionalSourceContexts, &google_devtools_source_v1.ExtendedSourceContext{})
			if err := m.AdditionalSourceContexts[len(m.AdditionalSourceContexts)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGrafeas(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGrafeas
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RepoSource) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGrafeas
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RepoSource: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RepoSource: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProjectId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGrafeas
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGrafeas
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ProjectId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RepoName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGrafeas
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGrafeas
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RepoName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BranchName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGrafeas
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGrafeas
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Revision = &RepoSource_BranchName{string(dAtA[iNdEx:postIndex])}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TagName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGrafeas
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGrafeas
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Revision = &RepoSource_TagName{string(dAtA[iNdEx:postIndex])}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CommitSha", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGrafeas
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGrafeas
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Revision = &RepoSource_CommitSha{string(dAtA[iNdEx:postIndex])}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGrafeas(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGrafeas
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *StorageSource) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGrafeas
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: StorageSource: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: StorageSource: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Bucket", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGrafeas
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGrafeas
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Bucket = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Generation", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGrafeas
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGrafeas
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Generation = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Object", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGrafeas
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGrafeas
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Object = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGrafeas(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGrafeas
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *VulnerabilityType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGrafeas
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: VulnerabilityType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: VulnerabilityType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 2:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field CvssScore", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.CvssScore = float32(math.Float32frombits(v))
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Severity", wireType)
			}
			m.Severity = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGrafeas
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Severity |= (VulnerabilityType_Severity(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Details", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGrafeas
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGrafeas
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Details = append(m.Details, &VulnerabilityType_Detail{})
			if err := m.Details[len(m.Details)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGrafeas(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGrafeas
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *VulnerabilityType_Version) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGrafeas
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Version: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Version: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Epoch", wireType)
			}
			m.Epoch = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGrafeas
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Epoch |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGrafeas
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGrafeas
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Revision", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGrafeas
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGrafeas
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Revision = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Kind", wireType)
			}
			m.Kind = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGrafeas
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Kind |= (VulnerabilityType_Version_VersionKind(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipGrafeas(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGrafeas
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *VulnerabilityType_Detail) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGrafeas
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Detail: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Detail: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CpeUri", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGrafeas
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGrafeas
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CpeUri = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SeverityName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGrafeas
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGrafeas
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SeverityName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FixedLocation", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGrafeas
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGrafeas
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.FixedLocation == nil {
				m.FixedLocation = &VulnerabilityType_VulnerabilityLocation{}
			}
			if err := m.FixedLocation.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MinAffectedVersion", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGrafeas
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGrafeas
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.MinAffectedVersion == nil {
				m.MinAffectedVersion = &VulnerabilityType_Version{}
			}
			if err := m.MinAffectedVersion.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxAffectedVersion", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGrafeas
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGrafeas
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.MaxAffectedVersion == nil {
				m.MaxAffectedVersion = &VulnerabilityType_Version{}
			}
			if err := m.MaxAffectedVersion.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Package", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGrafeas
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGrafeas
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Package = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Description", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGrafeas
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGrafeas
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Description = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PackageType", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGrafeas
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGrafeas
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PackageType = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGrafeas(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGrafeas
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *VulnerabilityType_VulnerabilityDetails) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGrafeas
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: VulnerabilityDetails: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: VulnerabilityDetails: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGrafeas
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGrafeas
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Type = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Severity", wireType)
			}
			m.Severity = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGrafeas
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Severity |= (VulnerabilityType_Severity(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field CvssScore", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.CvssScore = float32(math.Float32frombits(v))
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PackageIssue", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGrafeas
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGrafeas
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PackageIssue = append(m.PackageIssue, &VulnerabilityType_PackageIssue{})
			if err := m.PackageIssue[len(m.PackageIssue)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGrafeas(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGrafeas
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *VulnerabilityType_PackageIssue) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGrafeas
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PackageIssue: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PackageIssue: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AffectedLocation", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGrafeas
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGrafeas
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.AffectedLocation == nil {
				m.AffectedLocation = &VulnerabilityType_VulnerabilityLocation{}
			}
			if err := m.AffectedLocation.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FixedLocation", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGrafeas
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGrafeas
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.FixedLocation == nil {
				m.FixedLocation = &VulnerabilityType_VulnerabilityLocation{}
			}
			if err := m.FixedLocation.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SeverityName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGrafeas
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGrafeas
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SeverityName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGrafeas(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGrafeas
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *VulnerabilityType_VulnerabilityLocation) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGrafeas
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: VulnerabilityLocation: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: VulnerabilityLocation: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CpeUri", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGrafeas
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGrafeas
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CpeUri = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Package", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGrafeas
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGrafeas
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Package = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Version", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGrafeas
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGrafeas
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Version == nil {
				m.Version = &VulnerabilityType_Version{}
			}
			if err := m.Version.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGrafeas(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGrafeas
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipGrafeas(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowGrafeas
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowGrafeas
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowGrafeas
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			iNdEx += length
			if length < 0 {
				return 0, ErrInvalidLengthGrafeas
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowGrafeas
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipGrafeas(dAtA[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthGrafeas = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowGrafeas   = fmt.Errorf("proto: integer overflow")
)

func init() { proto.RegisterFile("v1alpha1/proto/grafeas.proto", fileDescriptorGrafeas) }

var fileDescriptorGrafeas = []byte{
	// 4178 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xbc, 0x3a, 0x4b, 0x6f, 0x1b, 0x49,
	0x7a, 0x6a, 0x8a, 0x12, 0xc9, 0x8f, 0xa4, 0xd4, 0xaa, 0x91, 0x6d, 0x0e, 0xed, 0xb1, 0xbd, 0xed,
	0x71, 0xec, 0xf1, 0xac, 0xa9, 0x91, 0x3c, 0xe3, 0x79, 0x65, 0xb2, 0xcb, 0x97, 0xc5, 0x5e, 0xf1,
	0x85, 0x26, 0x65, 0x5b, 0x9b, 0x20, 0x8d, 0x26, 0x59, 0xa2, 0x7a, 0x45, 0x76, 0x33, 0xdd, 0x4d,
	0x46, 0x9a, 0xc5, 0x04, 0xc1, 0xee, 0x06, 0x9b, 0x00, 0x39, 0x2c, 0xb2, 0x08, 0xb2, 0x87, 0x5c,
	0x92, 0x43, 0x0e, 0xb9, 0x2e, 0xf6, 0x10, 0xe4, 0x07, 0x24, 0xb9, 0xe5, 0x81, 0x1c, 0x03, 0x04,
	0xb3, 0x09, 0x10, 0x24, 0x39, 0xe5, 0x0f, 0x24, 0xa8, 0x47, 0x3f, 0x48, 0x35, 0x29, 0xca, 0x9e,
	0xcc, 0x89, 0x5d, 0x5f, 0x7d, 0xdf, 0x57, 0x5f, 0x55, 0x7d, 0x6f, 0x16, 0xdc, 0x9a, 0xec, 0x6a,
	0x83, 0xd1, 0x89, 0xb6, 0xbb, 0x33, 0xb2, 0x4c, 0xc7, 0xdc, 0xe9, 0x5b, 0xda, 0x31, 0xd6, 0xec,
	0x1c, 0x1d, 0xa1, 0x6d, 0x77, 0xe8, 0x62, 0xe5, 0xb4, 0x91, 0x9e, 0xbd, 0xd9, 0x37, 0xcd, 0xfe,
	0x00, 0x33, 0x8a, 0xce, 0xf8, 0x78, 0x07, 0x0f, 0x47, 0xce, 0x39, 0x23, 0xc9, 0xde, 0xe2, 0x93,
	0xda, 0x48, 0xdf, 0xd1, 0x0c, 0xc3, 0x74, 0x34, 0x47, 0x37, 0x0d, 0xce, 0x30, 0x7b, 0x67, 0x96,
	0xd4, 0xd1, 0x87, 0xd8, 0x76, 0xb4, 0xe1, 0x88, 0x23, 0xdc, 0xe3, 0x08, 0x03, 0xd3, 0xe8, 0x5b,
	0x63, 0xc3, 0xd0, 0x8d, 0xfe, 0x8e, 0x39, 0xc2, 0xd6, 0x14, 0x97, 0x1c, 0x47, 0xea, 0xe1, 0x89,
	0x63, 0x9a, 0x03, 0x7b, 0xc7, 0x36, 0xc7, 0x56, 0x17, 0xef, 0x4c, 0x76, 0xf9, 0x97, 0xda, 0x35,
	0x0d, 0x07, 0x9f, 0x39, 0x0c, 0x5f, 0x7a, 0x04, 0xdb, 0xfb, 0xd8, 0x69, 0x74, 0xbb, 0x63, 0xcb,
	0xc2, 0x46, 0x17, 0x2b, 0xf8, 0xb7, 0xc6, 0xd8, 0x76, 0x10, 0x82, 0xa8, 0xa1, 0x0d, 0x71, 0x46,
	0xb8, 0x2b, 0x3c, 0x4c, 0x28, 0xf4, 0x5b, 0xfa, 0x91, 0x00, 0xd7, 0xab, 0xba, 0x1d, 0xc0, 0xb6,
	0x5d, 0xf4, 0xeb, 0xb0, 0x7e, 0xac, 0x0f, 0x1c, 0x6c, 0x65, 0x22, 0x94, 0x80, 0x8f, 0xd0, 0x4d,
	0x48, 0x8c, 0xb4, 0x3e, 0x56, 0x6d, 0xfd, 0x73, 0x9c, 0x59, 0xbd, 0x2b, 0x3c, 0x5c, 0x53, 0xe2,
	0x04, 0xd0, 0xd2, 0x3f, 0xc7, 0xe8, 0x2d, 0x00, 0x3a, 0xe9, 0x98, 0xa7, 0xd8, 0xc8, 0x44, 0x29,
	0x21, 0x45, 0x6f, 0x13, 0x00, 0xe1, 0x39, 0xd2, 0x2c, 0x6c, 0x38, 0x99, 0x35, 0xc6, 0x93, 0x8d,
	0xa4, 0xc7, 0x70, 0xa3, 0x84, 0x07, 0xd8, 0xc1, 0xcb, 0x49, 0x6d, 0xc3, 0x8d, 0xa2, 0x85, 0xb5,
	0x30, 0xf4, 0x6f, 0x03, 0x98, 0x1e, 0x90, 0x4a, 0x9e, 0xdc, 0xbb, 0x9b, 0x0b, 0xbb, 0xd8, 0x5c,
	0x80, 0x38, 0x40, 0x13, 0x90, 0x71, 0x75, 0x4a, 0x46, 0x13, 0x6e, 0x1c, 0x8e, 0x7a, 0xda, 0x92,
	0x32, 0xbe, 0xbe, 0x20, 0xd2, 0xdb, 0xb0, 0xb1, 0x8f, 0x9d, 0xba, 0xe9, 0x2c, 0x3c, 0x8b, 0x1c,
	0x64, 0xa6, 0x6e, 0xfb, 0x32, 0xfc, 0x3f, 0x12, 0x40, 0x24, 0x37, 0x4e, 0xf0, 0xec, 0x45, 0x1b,
	0xf8, 0x3a, 0xef, 0xff, 0x01, 0x6c, 0xb1, 0xfb, 0xbf, 0x4c, 0xfa, 0xdf, 0x17, 0x60, 0x8b, 0x5d,
	0xfd, 0x25, 0x98, 0xe8, 0x06, 0xc4, 0x0c, 0xd3, 0xc1, 0xaa, 0xde, 0x73, 0xe5, 0x27, 0x43, 0xb9,
	0x87, 0x72, 0x10, 0x25, 0x5f, 0x54, 0xf4, 0xe4, 0x5e, 0x36, 0xfc, 0x4a, 0x28, 0x77, 0x8a, 0x17,
	0x90, 0x39, 0x3a, 0x25, 0xf3, 0x0b, 0xd8, 0x62, 0xfa, 0x70, 0x99, 0x24, 0xee, 0x82, 0x91, 0xe5,
	0x16, 0x24, 0x36, 0x99, 0x75, 0x6f, 0x28, 0xc4, 0x2e, 0xbf, 0xa6, 0xbb, 0x92, 0x7e, 0x2c, 0xc0,
	0xcd, 0x50, 0x31, 0xec, 0x91, 0x69, 0xd8, 0x18, 0xbd, 0x0d, 0x69, 0x03, 0x9f, 0x39, 0x4d, 0x97,
	0x80, 0x0b, 0x34, 0x0d, 0x44, 0x05, 0x48, 0xfa, 0x2a, 0x6d, 0x67, 0x22, 0x77, 0x57, 0x97, 0xb2,
	0x83, 0x20, 0x91, 0x74, 0x0a, 0x5b, 0x01, 0x8d, 0xbd, 0xd2, 0xf2, 0xef, 0xc1, 0x1a, 0x39, 0x53,
	0x77, 0xe1, 0x45, 0x87, 0xcf, 0x10, 0xa5, 0x1f, 0x0a, 0x70, 0xe3, 0x82, 0x47, 0xfc, 0xda, 0xb7,
	0xfc, 0x05, 0x77, 0xcb, 0x5e, 0x2c, 0xb8, 0xa2, 0x0c, 0x9f, 0x01, 0xf8, 0x71, 0x84, 0x8b, 0xf0,
	0x16, 0x0f, 0x24, 0xb9, 0x40, 0xb4, 0xc9, 0x79, 0x2b, 0x28, 0x01, 0x02, 0x49, 0x87, 0xeb, 0xdc,
	0xd7, 0x79, 0xd3, 0x0b, 0xb4, 0xef, 0x53, 0x48, 0x78, 0xb4, 0xdc, 0xac, 0x2e, 0x59, 0xcb, 0xc7,
	0x97, 0x7e, 0x22, 0xc0, 0x75, 0xee, 0xcc, 0x67, 0xd7, 0xf2, 0x2d, 0x4f, 0x08, 0x5a, 0x1e, 0xfa,
	0x06, 0xa4, 0x3c, 0x7a, 0xdf, 0xbe, 0x93, 0x1e, 0x4c, 0xee, 0xbd, 0x9e, 0x48, 0x3f, 0x16, 0x60,
	0xcb, 0x9b, 0xa8, 0x61, 0x47, 0xeb, 0x69, 0x8e, 0x86, 0x3e, 0x85, 0x64, 0x97, 0xca, 0xa9, 0x92,
	0x28, 0x4e, 0x45, 0xa2, 0x0a, 0xc5, 0x98, 0xba, 0x21, 0x3e, 0xd7, 0x76, 0x43, 0xbc, 0x02, 0x0c,
	0x9d, 0x00, 0xd0, 0x07, 0x10, 0xc7, 0x46, 0x8f, 0x51, 0x46, 0x2e, 0xa5, 0x8c, 0x61, 0xa3, 0x47,
	0x46, 0x52, 0x15, 0xe2, 0x79, 0xcb, 0xd1, 0x8f, 0xb5, 0xae, 0x83, 0xb2, 0x10, 0xef, 0x9e, 0xe0,
	0xee, 0xa9, 0x3d, 0x1e, 0xf2, 0xf3, 0xf0, 0xc6, 0x68, 0x03, 0x22, 0xde, 0x39, 0x44, 0xf4, 0x1e,
	0xda, 0x86, 0x35, 0x72, 0x33, 0x76, 0x66, 0xf5, 0xee, 0xea, 0xc3, 0x84, 0xc2, 0x06, 0xd2, 0x5f,
	0x47, 0x60, 0x3b, 0xef, 0x38, 0x64, 0x11, 0xb2, 0xb3, 0xfc, 0xd8, 0x39, 0x31, 0x2d, 0xdd, 0x39,
	0x47, 0x2f, 0x20, 0x7a, 0xa2, 0xf3, 0x63, 0x4e, 0xee, 0x15, 0xc3, 0x55, 0x35, 0x8c, 0x32, 0x14,
	0x58, 0xd1, 0x0d, 0x47, 0xa1, 0x0c, 0xb3, 0xdf, 0x81, 0xcc, 0x3c, 0x0c, 0x94, 0x83, 0x37, 0x4e,
	0xc6, 0x43, 0xcd, 0x50, 0x2d, 0xac, 0xf5, 0xb4, 0xce, 0x00, 0xab, 0x01, 0xc5, 0xda, 0xa2, 0x53,
	0x0a, 0x9f, 0xa9, 0x6b, 0x43, 0x9c, 0xfd, 0x1d, 0x48, 0x06, 0x78, 0xa1, 0x0e, 0x5c, 0x1f, 0xf5,
	0x47, 0xaa, 0xad, 0xf7, 0x0d, 0xdc, 0x53, 0x35, 0x7f, 0x86, 0xef, 0xe2, 0x51, 0xf8, 0x2e, 0x9a,
	0xfd, 0x51, 0x8b, 0x92, 0x04, 0x78, 0x55, 0x56, 0x94, 0xed, 0x51, 0x08, 0xbc, 0x90, 0x84, 0x04,
	0xe1, 0xaf, 0x39, 0x63, 0x0b, 0x4b, 0xbf, 0x2b, 0x40, 0xaa, 0x30, 0xd6, 0x07, 0xbd, 0x12, 0x76,
	0x34, 0x7d, 0x60, 0xa3, 0x32, 0xc0, 0xc8, 0x32, 0x27, 0xd8, 0xd0, 0x48, 0x84, 0x67, 0xab, 0xde,
	0x0f, 0x5f, 0x95, 0xd2, 0x35, 0x3d, 0x64, 0x25, 0x40, 0x88, 0xde, 0x01, 0xd1, 0x1f, 0xa9, 0x9d,
	0x73, 0xe6, 0xad, 0xc8, 0x21, 0x6c, 0xfa, 0xf0, 0x02, 0x01, 0x4b, 0x3f, 0x5f, 0x83, 0xcd, 0x19,
	0x56, 0xe8, 0x37, 0x20, 0xdd, 0x21, 0x20, 0xd5, 0x1c, 0x31, 0x63, 0x17, 0xa8, 0xb1, 0x7f, 0xb8,
	0x94, 0x20, 0x6c, 0xdc, 0x60, 0x94, 0x65, 0xc3, 0xb1, 0xce, 0x95, 0x54, 0x27, 0x00, 0x42, 0x0f,
	0x60, 0x93, 0x8e, 0xb1, 0xa5, 0x4e, 0xb0, 0x65, 0x93, 0xe3, 0x65, 0xb2, 0x6d, 0x70, 0xf0, 0x73,
	0x06, 0x45, 0xfb, 0x0c, 0xd1, 0x51, 0x35, 0xae, 0xaf, 0x4c, 0xf7, 0x92, 0x7b, 0xb7, 0xe7, 0x68,
	0x13, 0x47, 0x63, 0x8c, 0x1c, 0x77, 0x68, 0xa3, 0x8f, 0x21, 0xde, 0x35, 0x87, 0x43, 0xcd, 0xe8,
	0xd9, 0x99, 0xa8, 0xeb, 0xb7, 0xc2, 0x38, 0x14, 0x19, 0x96, 0xe2, 0xa1, 0xa3, 0x3b, 0xd3, 0x16,
	0xca, 0x52, 0x8c, 0xa0, 0x15, 0x66, 0x20, 0x46, 0x47, 0xa6, 0x95, 0x59, 0xa7, 0x93, 0xee, 0x90,
	0x90, 0x1e, 0xeb, 0x86, 0x6e, 0x9f, 0x30, 0xd2, 0x18, 0x23, 0x65, 0x20, 0x4a, 0xca, 0x2c, 0x2c,
	0xee, 0x59, 0xd8, 0x1d, 0x48, 0x0e, 0xcc, 0xbe, 0xad, 0x76, 0xc6, 0xdd, 0x53, 0xec, 0x64, 0x12,
	0x8c, 0x80, 0x80, 0x0a, 0x14, 0x42, 0xa3, 0xab, 0x65, 0x7e, 0x0f, 0x77, 0x1d, 0xe2, 0xa2, 0x80,
	0x47, 0x57, 0x06, 0x91, 0x29, 0xbd, 0x3b, 0x6d, 0x8c, 0x87, 0x99, 0x24, 0xa3, 0xe7, 0xa0, 0xfa,
	0x78, 0x88, 0x64, 0xd8, 0xe2, 0xd9, 0x7d, 0x40, 0xc9, 0x52, 0x54, 0xc9, 0x6e, 0x85, 0x1f, 0x48,
	0x8b, 0xa2, 0x2b, 0x22, 0x23, 0x0b, 0xa8, 0xc8, 0x5b, 0x00, 0xb6, 0xa3, 0x59, 0x0e, 0xdb, 0x5b,
	0x9a, 0x89, 0x42, 0x21, 0x74, 0x6b, 0x6f, 0x01, 0x38, 0x96, 0xde, 0xef, 0x63, 0x8b, 0x48, 0xba,
	0xc1, 0xa6, 0x39, 0x44, 0xee, 0x65, 0xbf, 0x05, 0x5b, 0x17, 0xb4, 0x04, 0x89, 0xb0, 0x7a, 0x8a,
	0xcf, 0xb9, 0xb1, 0x92, 0x4f, 0xe2, 0x72, 0x26, 0xda, 0x60, 0x8c, 0xb9, 0x7e, 0xb0, 0xc1, 0x27,
	0x91, 0x8f, 0x04, 0xe9, 0x3f, 0x04, 0xd8, 0xa0, 0x1c, 0x5a, 0xae, 0x2d, 0xa1, 0x6b, 0xb0, 0x7e,
	0x8a, 0xcf, 0xc9, 0x72, 0x8c, 0xc3, 0xda, 0x29, 0x3e, 0x97, 0x7b, 0x68, 0x1f, 0xe2, 0x04, 0xec,
	0x9c, 0x8f, 0x18, 0x9b, 0x8d, 0xbd, 0x6f, 0x2e, 0x50, 0x63, 0x8f, 0x5d, 0xee, 0x00, 0x9f, 0xb7,
	0xcf, 0x47, 0x58, 0x89, 0x9d, 0xb2, 0x0f, 0x7a, 0xf8, 0xe3, 0xce, 0x40, 0xef, 0xaa, 0x44, 0xca,
	0x55, 0x7e, 0xf8, 0x14, 0x72, 0x80, 0xcf, 0xd1, 0xad, 0x80, 0x5d, 0xbb, 0x89, 0x8f, 0x6f, 0xe8,
	0x1f, 0x43, 0x8c, 0x33, 0x44, 0x09, 0x58, 0x3b, 0xac, 0xb7, 0xca, 0x6d, 0x71, 0x05, 0x5d, 0x83,
	0xad, 0xe6, 0x7e, 0x53, 0xcd, 0xb7, 0x8a, 0xb2, 0xac, 0xe6, 0x95, 0x5a, 0x43, 0x29, 0x97, 0x44,
	0x01, 0xa5, 0x20, 0xde, 0x3c, 0x90, 0x5f, 0xaa, 0xcd, 0x72, 0x4d, 0x8c, 0x48, 0x67, 0x90, 0xa0,
	0xa2, 0x51, 0xe2, 0x10, 0xdb, 0x11, 0x42, 0x6d, 0xa7, 0x10, 0x14, 0x87, 0x45, 0x87, 0xb7, 0x97,
	0xd9, 0xb7, 0x32, 0xed, 0x9d, 0x62, 0xdc, 0x22, 0x48, 0x8c, 0xd6, 0xac, 0x3e, 0xf3, 0x04, 0x09,
	0x85, 0x7e, 0x93, 0x0b, 0xeb, 0xe9, 0x6e, 0x7a, 0x48, 0x3e, 0x09, 0x04, 0x1b, 0x13, 0x1e, 0x21,
	0xc8, 0x27, 0xd7, 0xf1, 0xa8, 0xa7, 0xe3, 0x6e, 0xac, 0x5f, 0x0b, 0xc4, 0xfa, 0x37, 0x21, 0xfe,
	0xdb, 0x9a, 0xee, 0xa8, 0xc7, 0xd4, 0x86, 0x08, 0x69, 0x8c, 0x8c, 0x9f, 0x99, 0x96, 0xf4, 0x77,
	0x11, 0x80, 0x12, 0x1e, 0x0d, 0xcc, 0x73, 0xe2, 0xb3, 0x49, 0x94, 0xb6, 0x30, 0x57, 0xe1, 0xb1,
	0xa5, 0x73, 0x69, 0x92, 0x2e, 0xec, 0xd0, 0xd2, 0xb3, 0x7f, 0xe2, 0x51, 0x0c, 0x49, 0x5c, 0xcf,
	0x40, 0x4c, 0xeb, 0xf5, 0x2c, 0x6c, 0xdb, 0xfc, 0xa0, 0xdc, 0x21, 0x6a, 0xc0, 0x7a, 0xd7, 0x34,
	0x8e, 0xf5, 0x3e, 0x4f, 0x65, 0xe6, 0x78, 0x37, 0x7f, 0xf5, 0x9c, 0xcf, 0x36, 0x57, 0xa4, 0x94,
	0xcc, 0xbb, 0x71, 0x36, 0xc4, 0xfc, 0x7a, 0x14, 0x83, 0xd9, 0x04, 0xd3, 0x10, 0x60, 0x20, 0x6a,
	0x14, 0xf7, 0x20, 0x3d, 0x36, 0x82, 0x28, 0xec, 0x58, 0x52, 0x2e, 0xd0, 0xb5, 0x9c, 0xb1, 0x8d,
	0x2d, 0x15, 0x0f, 0x35, 0x7d, 0xc0, 0x8f, 0x29, 0x41, 0x20, 0x65, 0x02, 0xc8, 0x7e, 0x0c, 0xc9,
	0xc0, 0xda, 0x57, 0xb2, 0x99, 0xbf, 0x5a, 0x87, 0x64, 0xc9, 0xec, 0x9e, 0x62, 0x4b, 0x1e, 0x6a,
	0x7d, 0x9c, 0xfd, 0xf7, 0x08, 0xac, 0x55, 0xb5, 0x73, 0x6c, 0x11, 0xdd, 0xd5, 0xac, 0xfe, 0x98,
	0xec, 0xcc, 0x3d, 0x26, 0x1f, 0x80, 0x1a, 0x90, 0xe8, 0xe9, 0x16, 0xee, 0x3a, 0xfa, 0xc4, 0x35,
	0xa1, 0xdd, 0x39, 0x67, 0xe5, 0x73, 0xcf, 0x51, 0xce, 0xb9, 0x92, 0x4b, 0xa8, 0xf8, 0x3c, 0xa4,
	0xff, 0x16, 0x20, 0xe1, 0x4d, 0x10, 0x23, 0x38, 0xac, 0x1f, 0xd4, 0x1b, 0x2f, 0xea, 0x6a, 0x49,
	0x56, 0xca, 0xc5, 0xb6, 0xfc, 0xbc, 0x2c, 0xae, 0xa0, 0x0d, 0x80, 0x5a, 0x5e, 0xae, 0xb7, 0xf3,
	0x72, 0xbd, 0xac, 0x88, 0x02, 0x8a, 0xc1, 0xaa, 0x72, 0x58, 0x17, 0x23, 0xe4, 0xa3, 0x58, 0x2b,
	0x89, 0xab, 0xc4, 0x90, 0xaa, 0xf9, 0x42, 0xb9, 0x2a, 0x46, 0x11, 0xc0, 0x7a, 0xf9, 0x65, 0xb3,
	0xd1, 0x2a, 0x8b, 0x6b, 0x64, 0xbe, 0x5c, 0x7f, 0x2e, 0xae, 0x93, 0x8f, 0x7c, 0xa9, 0x24, 0xc6,
	0x50, 0x1c, 0xa2, 0xc5, 0x46, 0xf3, 0x48, 0x8c, 0x13, 0xa6, 0xe5, 0x7a, 0x5b, 0x39, 0x6a, 0x36,
	0xe4, 0x7a, 0x5b, 0x4c, 0x10, 0xba, 0xe7, 0x8d, 0xea, 0x61, 0xad, 0x2c, 0x02, 0xc1, 0x3a, 0x6c,
	0x95, 0x15, 0x31, 0x89, 0x92, 0x10, 0x7b, 0xd1, 0x50, 0x0e, 0x4a, 0xb2, 0x22, 0xa6, 0x28, 0x17,
	0x65, 0x5f, 0x4c, 0x13, 0x68, 0xa3, 0x5e, 0x38, 0x94, 0xab, 0x25, 0x71, 0x83, 0x30, 0x6a, 0xb5,
	0x1b, 0xcd, 0x96, 0xbc, 0x5f, 0xcf, 0x57, 0xc5, 0x4d, 0xb4, 0x09, 0xc9, 0x4a, 0x39, 0x5f, 0x6d,
	0x57, 0x8a, 0x95, 0x72, 0xf1, 0x40, 0x14, 0x89, 0x70, 0xad, 0x4a, 0xb9, 0x5a, 0x15, 0xb7, 0xb2,
	0x2f, 0x21, 0xf9, 0x4c, 0x37, 0xfa, 0xd8, 0x1a, 0x59, 0x24, 0x47, 0xb9, 0x01, 0xb1, 0xc9, 0x6e,
	0x30, 0x2f, 0x59, 0x9f, 0xec, 0xd6, 0x79, 0x75, 0x39, 0xd9, 0x53, 0x3b, 0x03, 0xb3, 0x43, 0x35,
	0x92, 0x4c, 0xec, 0x15, 0x06, 0x66, 0x87, 0x4f, 0x50, 0x0a, 0xde, 0x3e, 0x98, 0xec, 0xd1, 0xf4,
	0xe5, 0xfb, 0xb0, 0x56, 0xd0, 0x6c, 0x9d, 0x5c, 0x11, 0x09, 0x35, 0xee, 0x12, 0x3c, 0x6f, 0x78,
	0x7c, 0xf9, 0x25, 0x05, 0xe4, 0x52, 0x82, 0x1c, 0x66, 0x0c, 0x6d, 0xe0, 0xa6, 0xc3, 0xbe, 0xa1,
	0x0d, 0xb2, 0xff, 0x29, 0x40, 0xac, 0x84, 0x2d, 0x7d, 0x82, 0x7b, 0xe8, 0x11, 0x6c, 0x75, 0x34,
	0x1b, 0xab, 0x53, 0x34, 0x6c, 0x77, 0x9b, 0x64, 0x42, 0xf1, 0xe9, 0x48, 0xce, 0xd9, 0xd3, 0x6d,
	0x47, 0x73, 0x5b, 0x18, 0x69, 0xc5, 0x1b, 0xcf, 0xee, 0x63, 0xf5, 0xb5, 0xf7, 0xf1, 0x0c, 0x60,
	0x40, 0x14, 0x51, 0xd5, 0x8d, 0x63, 0x93, 0xc7, 0xfe, 0x07, 0x4b, 0x2a, 0xaf, 0x92, 0xa0, 0xa4,
	0xb2, 0x71, 0x6c, 0x4a, 0x7f, 0x4a, 0x55, 0xd6, 0xee, 0x9a, 0x13, 0x6c, 0x9d, 0xa3, 0x12, 0xa4,
	0x35, 0x43, 0x1b, 0x9c, 0xdb, 0xba, 0xad, 0x9e, 0xea, 0x06, 0x8b, 0x38, 0x1b, 0x7b, 0x77, 0xe6,
	0x57, 0x82, 0xb9, 0x03, 0xdd, 0xe8, 0x29, 0x29, 0x97, 0x8a, 0x8c, 0xb2, 0x32, 0x80, 0xcb, 0x12,
	0xcf, 0x54, 0x17, 0xc2, 0x15, 0xab, 0x8b, 0x32, 0xc0, 0x33, 0x7d, 0x80, 0x2b, 0x9a, 0x7d, 0x82,
	0x6d, 0xf4, 0x21, 0x24, 0x8e, 0xf5, 0x01, 0x56, 0x4f, 0x34, 0xfb, 0x84, 0xa7, 0x6e, 0x73, 0x8a,
	0x54, 0x42, 0xa0, 0xc4, 0x8f, 0x39, 0xa9, 0x74, 0x06, 0x51, 0xf2, 0x8b, 0x9e, 0x40, 0x94, 0xc6,
	0xcb, 0x85, 0xdb, 0x22, 0x98, 0x39, 0x1a, 0x22, 0x29, 0x72, 0xb8, 0xe3, 0x91, 0xee, 0x43, 0x94,
	0x06, 0xae, 0x38, 0x44, 0xeb, 0x8d, 0x3a, 0x31, 0x6c, 0x80, 0xf5, 0x56, 0x25, 0xbf, 0xf7, 0xc1,
	0x53, 0x66, 0xd4, 0xb5, 0xd2, 0x07, 0x62, 0x44, 0xfa, 0x97, 0x04, 0x44, 0xc9, 0x39, 0x85, 0xd6,
	0x82, 0xef, 0xc2, 0x96, 0x7d, 0x62, 0x5a, 0x8e, 0xda, 0xc3, 0x76, 0xd7, 0xd2, 0x47, 0x5e, 0x01,
	0x96, 0x50, 0x44, 0x3a, 0x51, 0xf2, 0xe1, 0x24, 0xf5, 0x25, 0xc7, 0x35, 0x85, 0xcb, 0xfc, 0xec,
	0x26, 0x81, 0x07, 0x51, 0x5f, 0x02, 0x9a, 0x8c, 0x07, 0x06, 0xb6, 0xb4, 0x8e, 0x3e, 0xd0, 0x1d,
	0x9e, 0x24, 0xac, 0xd3, 0xb3, 0x9f, 0xa3, 0x24, 0xcf, 0x83, 0xf8, 0x64, 0x63, 0x95, 0x15, 0x65,
	0x6b, 0x32, 0x0b, 0x44, 0xcf, 0x20, 0x69, 0xe1, 0x81, 0xe6, 0xe0, 0x1e, 0xb5, 0x84, 0x18, 0xbd,
	0x83, 0xfb, 0x0b, 0xd4, 0x43, 0x61, 0xd8, 0x87, 0xd6, 0x40, 0x01, 0xcb, 0xfb, 0x46, 0xdf, 0x06,
	0x60, 0x89, 0x38, 0x95, 0x2c, 0x4e, 0x25, 0xbb, 0xb3, 0x20, 0x8c, 0x73, 0x89, 0x12, 0x1d, 0x2f,
	0x61, 0x78, 0x02, 0x51, 0xaa, 0xa1, 0x89, 0xe5, 0x34, 0x94, 0x22, 0xa3, 0x22, 0x6c, 0xe2, 0xb3,
	0x91, 0xce, 0xab, 0x61, 0x1a, 0xaa, 0xe0, 0xd2, 0x02, 0x73, 0xc3, 0x27, 0xa1, 0x81, 0x6c, 0xa6,
	0xb6, 0x4d, 0x5e, 0xa9, 0xb6, 0xfd, 0x14, 0x92, 0x63, 0xda, 0x2c, 0x60, 0xc4, 0xa9, 0xcb, 0x89,
	0x19, 0x3a, 0x25, 0xae, 0x00, 0x50, 0x6f, 0xa4, 0x13, 0x5b, 0xa6, 0xb9, 0xe9, 0x52, 0x46, 0x4f,
	0x5d, 0x29, 0x3d, 0x3d, 0xcd, 0xc6, 0x14, 0x84, 0x2a, 0x10, 0x1b, 0x69, 0xdd, 0x53, 0xc2, 0x66,
	0x83, 0xb2, 0x99, 0x93, 0x3b, 0x36, 0x19, 0x52, 0x4d, 0x33, 0xb4, 0x3e, 0xb6, 0xdc, 0x61, 0x65,
	0x45, 0x71, 0xc9, 0xd1, 0x7d, 0xd8, 0xf0, 0xfb, 0x0b, 0x54, 0xc3, 0x37, 0x59, 0x8f, 0xc5, 0x83,
	0xd2, 0x18, 0x50, 0x00, 0x9e, 0x30, 0x90, 0x84, 0x23, 0xb3, 0xb5, 0xa8, 0xc3, 0xeb, 0x27, 0x26,
	0x95, 0x15, 0x25, 0x40, 0x85, 0xbe, 0x45, 0xe2, 0x35, 0x77, 0x55, 0x19, 0xb4, 0x48, 0x67, 0x3c,
	0x8f, 0x46, 0x76, 0xed, 0xd1, 0x20, 0x0d, 0xae, 0x05, 0x6a, 0x5f, 0x55, 0x73, 0x4b, 0xec, 0xcc,
	0x1b, 0x8b, 0xaa, 0xe0, 0xd0, 0xa2, 0x7c, 0x45, 0xd9, 0xd6, 0x42, 0xe0, 0xd9, 0xf7, 0x01, 0x7c,
	0x95, 0x27, 0x59, 0x8c, 0x1f, 0x30, 0xc8, 0x27, 0x71, 0x26, 0x03, 0xad, 0x83, 0xdd, 0xc0, 0xc3,
	0x06, 0xd2, 0x5f, 0x0a, 0x10, 0x25, 0x6a, 0x8a, 0xb6, 0x41, 0x3c, 0x90, 0xeb, 0x25, 0xf5, 0xb0,
	0xde, 0x6a, 0x96, 0x8b, 0xf2, 0x33, 0xb9, 0x5c, 0x12, 0x57, 0xd0, 0x9b, 0x70, 0xad, 0x99, 0x2f,
	0x1e, 0xe4, 0xf7, 0xcb, 0xea, 0xf3, 0xc3, 0x6a, 0xbd, 0xac, 0xe4, 0x0b, 0x72, 0x55, 0x6e, 0x1f,
	0x89, 0x02, 0xda, 0x82, 0x34, 0x0d, 0xdd, 0x6a, 0xa9, 0xdc, 0xce, 0xcb, 0xd5, 0x96, 0x18, 0x21,
	0x21, 0x5b, 0xae, 0x11, 0xdc, 0x42, 0xbe, 0x25, 0xb7, 0xc4, 0x55, 0xf4, 0x06, 0x6c, 0xba, 0xe4,
	0xb5, 0x7c, 0x3d, 0xbf, 0x5f, 0x56, 0xc4, 0x28, 0x09, 0xf4, 0xa5, 0x72, 0xb3, 0xda, 0x38, 0xca,
	0x17, 0xaa, 0x24, 0xbb, 0x48, 0x43, 0xa2, 0x24, 0xb7, 0x8a, 0x8d, 0xe7, 0x65, 0xe5, 0x48, 0x5c,
	0x27, 0x4b, 0xe6, 0xdb, 0xed, 0x72, 0xab, 0x9d, 0x6f, 0xcb, 0x8d, 0xba, 0x9a, 0x3f, 0x6c, 0x57,
	0x1a, 0x0a, 0x59, 0x32, 0x46, 0x0a, 0x7d, 0xda, 0x2c, 0x26, 0xa6, 0x2b, 0xfd, 0x4d, 0x0c, 0xc0,
	0xef, 0xcb, 0x85, 0x7a, 0xb9, 0xcb, 0x43, 0x2e, 0xba, 0xc9, 0x59, 0x06, 0x52, 0x81, 0x38, 0x01,
	0x50, 0xd5, 0xb9, 0x4b, 0x7c, 0xce, 0x10, 0xf7, 0x74, 0x16, 0x42, 0xd6, 0x5c, 0x72, 0x0f, 0xe4,
	0xf9, 0x82, 0xf5, 0xab, 0xf8, 0x02, 0xd9, 0xed, 0x05, 0xf4, 0x58, 0x8b, 0x82, 0xd6, 0xb1, 0xc9,
	0x3d, 0x69, 0x81, 0x17, 0xe2, 0xcd, 0x8c, 0xca, 0x0a, 0x2f, 0xfc, 0xdd, 0xe6, 0x86, 0x0d, 0xd7,
	0xa6, 0xfd, 0xad, 0xcb, 0x92, 0x39, 0xb6, 0x5f, 0x5d, 0xd2, 0xe5, 0x4e, 0x43, 0xfc, 0xc5, 0xb6,
	0x27, 0x21, 0xf0, 0x59, 0x37, 0x94, 0x78, 0x1d, 0x37, 0x04, 0x57, 0x72, 0x43, 0x4d, 0x48, 0xf7,
	0x58, 0x7e, 0xc4, 0x3d, 0x11, 0x73, 0x81, 0xef, 0x5c, 0xee, 0x89, 0x78, 0x5a, 0x45, 0x0e, 0x90,
	0x73, 0x60, 0xee, 0xe8, 0x05, 0xa4, 0x74, 0xc3, 0x76, 0xb4, 0xc1, 0x80, 0xdd, 0x31, 0x73, 0x8b,
	0xbb, 0x4b, 0xf9, 0x24, 0x39, 0x40, 0x48, 0x18, 0x07, 0x19, 0x85, 0x78, 0xa7, 0x74, 0x98, 0x77,
	0xaa, 0xb9, 0xde, 0x89, 0x14, 0x06, 0xdc, 0x23, 0xbe, 0x7b, 0x85, 0xb2, 0xc9, 0x77, 0x54, 0xb4,
	0x36, 0xab, 0x02, 0xf4, 0xbc, 0x04, 0x88, 0xfa, 0xc3, 0xb9, 0xce, 0xc5, 0xf3, 0x54, 0x39, 0x3f,
	0x65, 0xa2, 0xdc, 0xfc, 0x04, 0xea, 0xbb, 0x90, 0x0c, 0x76, 0xec, 0x44, 0xca, 0xee, 0xe9, 0xab,
	0xf5, 0x1d, 0x2b, 0x2b, 0x4a, 0x90, 0x59, 0x21, 0x01, 0x31, 0xae, 0xab, 0xd2, 0x2f, 0x62, 0xb0,
	0x31, 0x7d, 0xb4, 0x59, 0x07, 0x62, 0x1c, 0x82, 0x0e, 0x21, 0x45, 0x92, 0x59, 0x4b, 0xef, 0x8c,
	0x79, 0x22, 0xb7, 0xba, 0xf4, 0x0d, 0x95, 0x02, 0x84, 0xca, 0x14, 0x1b, 0xcf, 0x5f, 0x44, 0x7c,
	0x7f, 0x91, 0xfd, 0x65, 0x04, 0x52, 0x41, 0x12, 0xd4, 0x81, 0x94, 0x66, 0x75, 0x4f, 0x74, 0x07,
	0x77, 0x69, 0xd5, 0xcf, 0xb2, 0xb7, 0x5f, 0xbb, 0xf2, 0xda, 0xb9, 0x7c, 0x80, 0x8b, 0x32, 0xc5,
	0x93, 0x94, 0x22, 0xdd, 0x11, 0xab, 0xbd, 0xf9, 0xbf, 0x42, 0xdd, 0x11, 0x29, 0xbb, 0x89, 0xf7,
	0xb9, 0x98, 0x9d, 0x05, 0x41, 0xa8, 0x05, 0x1b, 0xc4, 0xe1, 0xdb, 0x8e, 0xd7, 0xb9, 0x88, 0x5e,
	0x21, 0xa4, 0xf2, 0xbe, 0x86, 0x92, 0x66, 0x3c, 0xdc, 0x36, 0xc7, 0x6d, 0x80, 0xa1, 0xa6, 0x1b,
	0x8e, 0xa6, 0x1b, 0xd8, 0x72, 0xbb, 0x73, 0x3e, 0xc4, 0x8d, 0x2c, 0xeb, 0x5e, 0x64, 0x91, 0x1e,
	0x43, 0x2a, 0xb8, 0x3f, 0x52, 0xd6, 0xf1, 0xf2, 0x53, 0x5c, 0x21, 0xf9, 0xe8, 0xcb, 0x8f, 0x78,
	0x62, 0xfa, 0xf2, 0xe9, 0xfb, 0x62, 0x24, 0xfb, 0x8f, 0x02, 0xc4, 0xdc, 0xc5, 0xb6, 0x61, 0x0d,
	0x8f, 0xcc, 0xee, 0x09, 0x3d, 0xd9, 0x35, 0x85, 0x0d, 0xc2, 0xee, 0x86, 0xd4, 0x38, 0x16, 0x9e,
	0xe8, 0xb6, 0x7f, 0x14, 0xde, 0x18, 0x55, 0xb9, 0x17, 0x5e, 0xa3, 0xd7, 0xf3, 0xd1, 0x55, 0x76,
	0xef, 0xfe, 0xfa, 0xee, 0x59, 0x7a, 0x02, 0xc9, 0x00, 0x90, 0x24, 0xd7, 0xf5, 0x86, 0x52, 0xcb,
	0x57, 0xc5, 0x15, 0xb2, 0xb3, 0x9a, 0x5c, 0x97, 0x6b, 0x87, 0x35, 0x51, 0xa0, 0x83, 0xfc, 0x4b,
	0x3a, 0x88, 0x64, 0x7f, 0x20, 0x40, 0xbc, 0x6a, 0x76, 0x99, 0xed, 0x07, 0xae, 0x54, 0x98, 0xba,
	0x52, 0x04, 0xd1, 0x91, 0xe6, 0x9c, 0xb8, 0x1b, 0x23, 0xdf, 0x48, 0x86, 0x98, 0x7b, 0x7b, 0xac,
	0x38, 0xdb, 0x59, 0xda, 0x69, 0xf3, 0x0b, 0x74, 0xe9, 0xb3, 0x43, 0x48, 0x05, 0x7d, 0x52, 0x68,
	0x4c, 0x94, 0x21, 0x3e, 0xe0, 0x72, 0xf2, 0x2e, 0xcd, 0xe3, 0xa5, 0xce, 0xcb, 0xdd, 0x9c, 0xe2,
	0x91, 0x4b, 0xff, 0x2b, 0xc0, 0x76, 0x58, 0xa3, 0x7e, 0xba, 0x71, 0x27, 0xcc, 0x34, 0xee, 0x88,
	0x82, 0x8d, 0xfa, 0x23, 0x95, 0x77, 0x16, 0xe9, 0x51, 0x54, 0x56, 0x94, 0xf8, 0xa8, 0x3f, 0x3a,
	0xa0, 0xed, 0xc5, 0x23, 0x48, 0xd1, 0x97, 0x12, 0x86, 0xc3, 0x72, 0xf4, 0x55, 0x7a, 0xab, 0x4f,
	0x97, 0xff, 0xa3, 0x20, 0x57, 0x64, 0xe4, 0xb4, 0x92, 0x4a, 0x76, 0xfd, 0x81, 0x54, 0xa2, 0xad,
	0x1e, 0x77, 0x88, 0x6e, 0x41, 0xa6, 0xd8, 0xa8, 0xb7, 0xcb, 0xf5, 0xb6, 0xda, 0x3e, 0x6a, 0x96,
	0x67, 0x72, 0x9f, 0x1b, 0xf0, 0x46, 0x4b, 0xae, 0x35, 0xab, 0x65, 0xb5, 0x25, 0xef, 0xd7, 0xe5,
	0xfa, 0xbe, 0xfa, 0x9d, 0x56, 0xa3, 0x2e, 0x0a, 0x85, 0xb8, 0xdb, 0x16, 0x95, 0x7e, 0xb8, 0x06,
	0xeb, 0xac, 0x9f, 0x8b, 0x9a, 0xb0, 0x61, 0x3b, 0xa6, 0x45, 0xff, 0xc6, 0xa5, 0x10, 0x5e, 0x71,
	0xde, 0x9b, 0xd3, 0x05, 0x66, 0xb8, 0x8c, 0xb8, 0x10, 0xc9, 0x08, 0x95, 0x15, 0x25, 0x6d, 0x07,
	0x81, 0x68, 0x9f, 0x64, 0x1f, 0x23, 0xd3, 0x65, 0xb7, 0xf0, 0x6d, 0x82, 0x82, 0x47, 0xe6, 0x14,
	0x2f, 0xb0, 0x3c, 0x08, 0xaa, 0x41, 0xd2, 0x2b, 0x5e, 0xb1, 0xdb, 0xf0, 0xff, 0xe6, 0xa2, 0xee,
	0x74, 0xce, 0x2f, 0x7d, 0x59, 0x43, 0x0e, 0x8e, 0xfd, 0x5a, 0xf8, 0xd7, 0xe1, 0x86, 0xfb, 0xef,
	0x81, 0x3a, 0xb3, 0xe5, 0xe8, 0xd2, 0x5b, 0x56, 0xae, 0xb9, 0x3c, 0xa6, 0xc0, 0xe8, 0x05, 0x6c,
	0x4c, 0xbf, 0x96, 0xa1, 0x46, 0x9d, 0xdc, 0x7b, 0xcf, 0xcd, 0x10, 0xdc, 0xe7, 0x35, 0x39, 0x86,
	0x96, 0x9b, 0xec, 0xe6, 0xca, 0x67, 0x0e, 0x36, 0x7a, 0xb8, 0xc7, 0x58, 0x14, 0x19, 0x9d, 0x92,
	0xb6, 0x83, 0x43, 0x64, 0x40, 0x56, 0xeb, 0xf5, 0x74, 0xa2, 0x1f, 0xda, 0x40, 0x9d, 0x5e, 0xc3,
	0xa6, 0x3d, 0xd2, 0x57, 0x59, 0x24, 0xe3, 0xf3, 0x9c, 0x9a, 0xb0, 0xb3, 0x2a, 0x6c, 0xce, 0x1c,
	0x62, 0x48, 0x67, 0xf1, 0x69, 0xb0, 0xc0, 0x9f, 0x7b, 0xb9, 0x3e, 0x9f, 0x40, 0xef, 0x91, 0x68,
	0x21, 0x93, 0x4e, 0xfa, 0x85, 0x40, 0x52, 0x7f, 0xef, 0xba, 0xa7, 0xff, 0xd2, 0x10, 0x66, 0xff,
	0xd2, 0xb8, 0x09, 0x09, 0xaa, 0x56, 0x01, 0x0f, 0x1b, 0x27, 0x80, 0x3a, 0xcb, 0x98, 0x93, 0x1d,
	0x4b, 0x33, 0xba, 0x27, 0x81, 0x84, 0x98, 0x68, 0x13, 0x03, 0x52, 0x94, 0x9b, 0x10, 0x77, 0xb4,
	0x3e, 0x9b, 0x8f, 0xf2, 0xf9, 0x98, 0xa3, 0xf5, 0xe9, 0xe4, 0x1d, 0x80, 0xae, 0x39, 0x1c, 0xea,
	0x8e, 0x6a, 0x9f, 0x68, 0x2c, 0x78, 0x90, 0x42, 0x88, 0xc1, 0x5a, 0x27, 0x5a, 0x01, 0x7c, 0x37,
	0x2e, 0xa9, 0x90, 0x9e, 0xbe, 0xfc, 0xeb, 0xb0, 0xce, 0xff, 0xa8, 0xe1, 0x6e, 0x93, 0x8d, 0x88,
	0xc7, 0xe8, 0x63, 0xc3, 0xed, 0xe4, 0x30, 0x99, 0x03, 0x10, 0x42, 0x67, 0x76, 0xc8, 0xf6, 0xdc,
	0x66, 0x1e, 0x1b, 0x49, 0xff, 0x95, 0x82, 0xad, 0x0b, 0x6e, 0x93, 0x9c, 0x4f, 0x77, 0x62, 0xdb,
	0xaa, 0xdd, 0x35, 0x79, 0x23, 0x3f, 0xa2, 0x24, 0x08, 0xa4, 0x45, 0x00, 0xa8, 0x0a, 0x71, 0x1b,
	0x4f, 0x30, 0xad, 0xce, 0x98, 0xeb, 0x79, 0x6f, 0x59, 0x87, 0xdc, 0xe2, 0x74, 0x8a, 0xc7, 0x81,
	0x94, 0xbb, 0x6e, 0x4a, 0xce, 0x5a, 0x65, 0xb9, 0x65, 0x99, 0xb1, 0x6c, 0x5b, 0x71, 0xc9, 0xb3,
	0xff, 0xfc, 0x95, 0x87, 0xcd, 0xc6, 0x54, 0xd8, 0xfc, 0xf4, 0x8a, 0x61, 0xe7, 0xab, 0x8a, 0x9c,
	0xff, 0xb0, 0x0a, 0xeb, 0x6c, 0xaf, 0xf3, 0xe3, 0xe6, 0x3d, 0x48, 0xbb, 0x27, 0x1a, 0x50, 0x3c,
	0x25, 0xe5, 0x02, 0xa9, 0xee, 0xf5, 0x60, 0xe3, 0x58, 0x3f, 0xc3, 0x3d, 0xd5, 0x8b, 0x6f, 0xcc,
	0x75, 0x7c, 0xf6, 0x4a, 0x45, 0x90, 0x17, 0xef, 0xd2, 0x94, 0xa9, 0x17, 0xdb, 0x35, 0xd8, 0x1e,
	0xea, 0x86, 0xaa, 0x1d, 0x1f, 0xe3, 0xae, 0x83, 0x7b, 0x5e, 0xe6, 0xb5, 0xfe, 0x6a, 0xb1, 0x1b,
	0x0d, 0x75, 0x23, 0xcf, 0x79, 0xb9, 0xb7, 0x4b, 0x96, 0xd0, 0xce, 0x2e, 0x2e, 0x11, 0x7b, 0xd5,
	0x25, 0xb4, 0xb3, 0xd9, 0x25, 0x32, 0x7e, 0x17, 0x86, 0xfd, 0x59, 0xea, 0x75, 0x55, 0x66, 0xb2,
	0xce, 0xc4, 0xc5, 0xac, 0xf3, 0x1b, 0x90, 0xe2, 0xc8, 0x2c, 0x3e, 0xb3, 0x3f, 0x4d, 0x93, 0x1c,
	0x46, 0x96, 0xce, 0xfe, 0x8f, 0x00, 0xdb, 0x61, 0x25, 0x25, 0x51, 0x51, 0x2f, 0xa6, 0x27, 0x78,
	0x97, 0x33, 0x68, 0x70, 0xd1, 0xd7, 0x36, 0xb8, 0x69, 0xeb, 0x5e, 0x9b, 0xb5, 0xee, 0x23, 0x48,
	0xbb, 0xc2, 0xeb, 0xb6, 0x3d, 0xc6, 0xdc, 0xf3, 0xbf, 0xbf, 0xec, 0x8a, 0x3c, 0x2b, 0x92, 0x09,
	0xad, 0xe2, 0x9e, 0x03, 0x1d, 0x65, 0x7f, 0x2f, 0x02, 0xa9, 0xe0, 0x34, 0xfa, 0x1e, 0x6c, 0x79,
	0x77, 0xe8, 0xe9, 0xa4, 0xf0, 0x55, 0xe8, 0xa4, 0xe8, 0xf2, 0xf5, 0xd4, 0xf2, 0xa2, 0xf2, 0x47,
	0xfe, 0x1f, 0x94, 0xff, 0x82, 0x1d, 0xae, 0x5e, 0xb4, 0xc3, 0xec, 0x1f, 0x0b, 0x70, 0x2d, 0x94,
	0xdb, 0x7c, 0xfb, 0x0e, 0xa8, 0x63, 0x64, 0x5a, 0x1d, 0x03, 0xd9, 0x71, 0xf4, 0xf5, 0xb2, 0x63,
	0xe9, 0x37, 0x21, 0xee, 0xea, 0x0b, 0xca, 0xc0, 0x76, 0xab, 0xfc, 0xbc, 0xac, 0xc8, 0xed, 0xa3,
	0x99, 0xac, 0xcf, 0x75, 0x54, 0xf9, 0x2a, 0xab, 0x59, 0xaa, 0x8d, 0x17, 0x62, 0x84, 0xb8, 0xb2,
	0x5a, 0xb9, 0x24, 0x1f, 0xd6, 0xc4, 0x55, 0x14, 0x87, 0x68, 0x45, 0xde, 0xaf, 0x88, 0x51, 0x94,
	0x82, 0x78, 0x51, 0x91, 0xdb, 0x72, 0x31, 0x5f, 0x15, 0xd7, 0xf6, 0xfe, 0x42, 0x84, 0xd8, 0x3e,
	0x93, 0x0d, 0xfd, 0x44, 0x80, 0xf4, 0xd4, 0x7b, 0x4f, 0x34, 0xa7, 0x0a, 0x0f, 0x7b, 0x02, 0x9c,
	0xbd, 0xf4, 0x15, 0x9a, 0xb4, 0xfb, 0x83, 0x7f, 0xfa, 0xb7, 0x9f, 0x46, 0xde, 0x45, 0xef, 0xec,
	0x78, 0x4f, 0xa5, 0xbf, 0x4f, 0x2e, 0xe4, 0x33, 0x1e, 0xe7, 0xed, 0x9d, 0x47, 0x3b, 0x81, 0x87,
	0x6a, 0x3b, 0x8f, 0xbe, 0x40, 0x7f, 0x26, 0xc0, 0xe6, 0xcc, 0x8b, 0x39, 0x34, 0x27, 0x09, 0x0c,
	0x7f, 0x6a, 0x9c, 0x7d, 0xbc, 0x24, 0x36, 0x7b, 0x02, 0x17, 0x2a, 0x23, 0x7b, 0x1a, 0x16, 0x90,
	0xf2, 0x8b, 0xa0, 0x98, 0xe8, 0x0f, 0x05, 0x10, 0x67, 0x5f, 0x18, 0xa3, 0x79, 0x7f, 0x56, 0x85,
	0xbf, 0x44, 0xce, 0x5e, 0xbf, 0xd0, 0x4b, 0x2a, 0x0f, 0x47, 0xce, 0xb9, 0x2b, 0xce, 0xa3, 0x2b,
	0x1c, 0xd9, 0x9f, 0x0b, 0x20, 0xce, 0xbe, 0x60, 0x9e, 0x27, 0xce, 0x9c, 0x97, 0xce, 0x4b, 0xdc,
	0xe5, 0x67, 0x54, 0xb0, 0x0f, 0xa5, 0xe5, 0xcf, 0xe9, 0x93, 0xe0, 0x43, 0x68, 0x22, 0xe4, 0xec,
	0x8b, 0xe7, 0x79, 0x42, 0xce, 0x79, 0x19, 0xbd, 0xbc, 0x90, 0x7b, 0xcb, 0x9f, 0xde, 0x94, 0x90,
	0x3f, 0x13, 0x60, 0xeb, 0xc2, 0xfb, 0x67, 0x94, 0x5b, 0xc2, 0x26, 0x02, 0xcf, 0x76, 0xb3, 0x0b,
	0xde, 0x85, 0x4a, 0x1f, 0x52, 0x01, 0x77, 0xd1, 0xce, 0xd2, 0x02, 0xee, 0xd0, 0x97, 0xa4, 0xe8,
	0x0c, 0x62, 0xfc, 0xfd, 0x36, 0x7a, 0x7b, 0xae, 0x3c, 0xcb, 0x4a, 0xf1, 0x2e, 0x95, 0xe2, 0x3e,
	0xba, 0xb7, 0x40, 0x0a, 0xba, 0x2c, 0x51, 0xaf, 0x3f, 0x10, 0x20, 0xe1, 0xbd, 0x98, 0x45, 0xbf,
	0x32, 0xdf, 0xba, 0x82, 0x8f, 0xc0, 0xb3, 0x0f, 0x2e, 0xc5, 0xe3, 0xf6, 0x17, 0x26, 0x4b, 0x88,
	0x5e, 0xb1, 0x53, 0xf8, 0x1c, 0xc0, 0x7f, 0xda, 0x8d, 0x1e, 0x2c, 0x32, 0xb9, 0xe0, 0x59, 0xcc,
	0x33, 0x36, 0xbe, 0xf6, 0xa3, 0xa5, 0xce, 0xe1, 0x47, 0x02, 0x80, 0xff, 0x5a, 0x7c, 0xde, 0xe2,
	0x17, 0xde, 0x93, 0x2f, 0xbc, 0x08, 0x6e, 0xed, 0xd2, 0x32, 0x9b, 0xff, 0x84, 0xbd, 0x20, 0x27,
	0x62, 0xf8, 0x4f, 0xc5, 0xe7, 0x89, 0x71, 0xe1, 0x31, 0xf9, 0x32, 0x62, 0xec, 0x2d, 0x73, 0x0e,
	0x5c, 0x8c, 0x9f, 0x0b, 0xf0, 0x46, 0xc8, 0x83, 0x6e, 0xf4, 0xde, 0xe2, 0x7b, 0x0f, 0xf1, 0xd7,
	0xbb, 0x57, 0xa0, 0xe0, 0x3a, 0xb3, 0x8c, 0x15, 0xb9, 0xf2, 0x4e, 0x79, 0xee, 0x9f, 0x0a, 0xb0,
	0x39, 0xf3, 0x3e, 0x78, 0x5e, 0x74, 0x09, 0x7f, 0x46, 0x9c, 0x5d, 0xfc, 0xd7, 0xbc, 0xf4, 0x84,
	0x4a, 0xf6, 0x58, 0x7a, 0x78, 0x89, 0x97, 0xf4, 0x5e, 0x47, 0x7f, 0x22, 0x3c, 0xa2, 0x52, 0xcd,
	0xbc, 0x90, 0x9e, 0x27, 0x55, 0xf8, 0x43, 0xea, 0x25, 0xa5, 0xda, 0x7b, 0xb8, 0xc8, 0xeb, 0x78,
	0x22, 0x91, 0x4b, 0x16, 0x1e, 0x15, 0xde, 0xfc, 0xdb, 0x2f, 0x6f, 0x0b, 0x7f, 0xff, 0xe5, 0x6d,
	0xe1, 0x5f, 0xbf, 0xbc, 0x2d, 0xfc, 0xec, 0x97, 0xb7, 0x57, 0xbe, 0x1b, 0xe3, 0x22, 0x75, 0xd6,
	0xa9, 0x1d, 0x3d, 0xf9, 0xbf, 0x00, 0x00, 0x00, 0xff, 0xff, 0x86, 0x6c, 0xf6, 0x83, 0x02, 0x35,
	0x00, 0x00,
}
